#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///`AccountCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_type",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "account_subtype": {
    ///      "examples": [
    ///        "PERSONAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "account_type": {
    ///      "examples": [
    ///        "SAVINGS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "apr": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "apy": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "available_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "cash_surrender_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "credit_limit": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "death_benefit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "interest_rate": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "is_business": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_closed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_hidden": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "loan_amount": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Test account 2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nickname": {
    ///      "examples": [
    ///        "Swiss Account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "original_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "property_type": {
    ///      "examples": [
    ///        "VEHICLE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_webhook": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_subtype: ::std::option::Option<::std::string::String>,
        pub account_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apy: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_surrender_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_limit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub death_benefit: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interest_rate: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_business: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_closed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nickname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub property_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_webhook: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&AccountCreateRequest> for AccountCreateRequest {
        fn from(value: &AccountCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`AccountCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/AccountCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account: ::std::option::Option<AccountCreateRequest>,
    }

    impl ::std::convert::From<&AccountCreateRequestBody> for AccountCreateRequestBody {
        fn from(value: &AccountCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountCreateRequestBody {
        fn default() -> Self {
            Self {
                account: Default::default(),
            }
        }
    }

    ///`AccountNumberResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-06d7f45b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "account_number": {
    ///      "examples": [
    ///        "10001"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "ACN-8899832e-e5b4-42cd-aa25-bbf1dc889a8f"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "institution_number": {
    ///      "examples": [
    ///        "123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "loan_guarantor": {
    ///      "examples": [
    ///        "U.S. DEPARTMENT OF EDUCATION (123456)"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "loan_reference_number": {
    ///      "examples": [
    ///        "123456789012345"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "passed_validation": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        "68899990000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "sequence_number": {
    ///      "examples": [
    ///        "1-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transit_number": {
    ///      "examples": [
    ///        "12345"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountNumberResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_guarantor: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_reference_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub passed_validation: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sequence_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transit_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AccountNumberResponse> for AccountNumberResponse {
        fn from(value: &AccountNumberResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountNumberResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_number: Default::default(),
                guid: Default::default(),
                institution_number: Default::default(),
                loan_guarantor: Default::default(),
                loan_reference_number: Default::default(),
                member_guid: Default::default(),
                passed_validation: Default::default(),
                routing_number: Default::default(),
                sequence_number: Default::default(),
                transit_number: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`AccountNumbersResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_numbers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountNumberResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountNumbersResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub account_numbers: ::std::vec::Vec<AccountNumberResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&AccountNumbersResponseBody> for AccountNumbersResponseBody {
        fn from(value: &AccountNumbersResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountNumbersResponseBody {
        fn default() -> Self {
            Self {
                account_numbers: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`AccountOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "address": {
    ///      "examples": [
    ///        "123 This Way"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "city": {
    ///      "examples": [
    ///        "Middlesex"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "country": {
    ///      "examples": [
    ///        "US"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "donnie@darko.co"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_name": {
    ///      "examples": [
    ///        "Donnie"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "ACO-63dc7714-6fc0-4aa2-a069-c06cdccd1af9"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "last_name": {
    ///      "examples": [
    ///        "Darko"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "owner_name": {
    ///      "examples": [
    ///        "Donnie Darko"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "examples": [
    ///        "555-555-5555"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "postal_code": {
    ///      "examples": [
    ///        "00000-0000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "state": {
    ///      "examples": [
    ///        "VA"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AccountOwnerResponse> for AccountOwnerResponse {
        fn from(value: &AccountOwnerResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountOwnerResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                address: Default::default(),
                city: Default::default(),
                country: Default::default(),
                email: Default::default(),
                first_name: Default::default(),
                guid: Default::default(),
                last_name: Default::default(),
                member_guid: Default::default(),
                owner_name: Default::default(),
                phone: Default::default(),
                postal_code: Default::default(),
                state: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`AccountOwnersResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_owners": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountOwnerResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountOwnersResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub account_owners: ::std::vec::Vec<AccountOwnerResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&AccountOwnersResponseBody> for AccountOwnersResponseBody {
        fn from(value: &AccountOwnersResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountOwnersResponseBody {
        fn default() -> Self {
            Self {
                account_owners: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`AccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_number": {
    ///      "examples": [
    ///        "5366"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "account_number_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "account_ownership": {
    ///      "examples": [
    ///        "INDIVIDUAL"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "annuity_policy_to_date": {
    ///      "examples": [
    ///        "2016-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "annuity_provider": {
    ///      "examples": [
    ///        "Metlife"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "annuity_term_year": {
    ///      "examples": [
    ///        2048
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "apr": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "apr_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "apy": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "apy_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "available_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "available_balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "available_credit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "available_credit_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "balance": {
    ///      "examples": [
    ///        10000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "calculated_apr": {
    ///      "examples": [
    ///        21.66409
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "cash_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "cash_balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "cash_surrender_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "cash_surrender_value_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2023-07-25T17:14:46Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "credit_limit": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "credit_limit_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "currency_code_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "day_payment_is_due": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "day_payment_is_due_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "death_benefit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "death_benefit_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "federal_insurance_status": {
    ///      "examples": [
    ///        "INSURED"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_account_number": {
    ///      "examples": [
    ///        "5366"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_account_subtype": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_account_type": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_apr": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_apy": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_available_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_cash_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_cash_surrender_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_credit_limit": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_day_payment_is_due": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_death_benefit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_holdings_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_interest_rate": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_is_closed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_last_payment": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_last_payment_at": {
    ///      "examples": [
    ///        "2023-07-25T17:14:46Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_loan_amount": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_matures_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_minimum_balance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_minimum_payment": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_name": {
    ///      "examples": [
    ///        "Test account 2"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_nickname": {
    ///      "examples": [
    ///        "My Checking"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_original_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_payment_due_at": {
    ///      "examples": [
    ///        "2025-02-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_payoff_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_routing_number": {
    ///      "examples": [
    ///        "68899990000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_started_on": {
    ///      "examples": [
    ///        "2020-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_statement_balance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "feed_total_account_value": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "holdings_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "holdings_value_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "1040434698"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "imported_at": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "institution_code": {
    ///      "examples": [
    ///        "3af3685e-05d9-7060-359f-008d0755e993"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "institution_guid": {
    ///      "examples": [
    ///        "INS-12a3b-4c5dd6-1349-008d0755e993"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "insured_name": {
    ///      "examples": [
    ///        "Tommy Shelby"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "interest_rate": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "interest_rate_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_closed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_closed_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_hidden": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_manual": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "last_payment": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "last_payment_at": {
    ///      "examples": [
    ///        "2023-07-25T17:14:46Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "last_payment_at_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "last_payment_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "loan_amount": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "loan_amount_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "margin_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "matures_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "matures_on_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_id": {
    ///      "examples": [
    ///        "member123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_is_managed_by_user": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "minimum_balance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "minimum_balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "minimum_payment": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "minimum_payment_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Test account 2"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "nickname": {
    ///      "examples": [
    ///        "My Checking"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "nickname_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "original_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "original_balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "pay_out_amount": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "payment_due_at": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "payment_due_at_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "payoff_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "payoff_balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "premium_amount": {
    ///      "examples": [
    ///        3900
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "property_type": {
    ///      "examples": [
    ///        "VEHICLE"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        "68899990000000"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "started_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "started_on_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "statement_balance": {
    ///      "examples": [
    ///        1000.5
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "statement_balance_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "subtype": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subtype_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "today_ugl_amount": {
    ///      "examples": [
    ///        1000.5
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "today_ugl_percentage": {
    ///      "examples": [
    ///        6.9
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "total_account_value": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "total_account_value_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "total_account_value_ugl": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "SAVINGS"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type_set_by": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:08:00.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "examples": [
    ///        "user123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_ownership: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub annuity_policy_to_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub annuity_provider: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub annuity_term_year: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apr_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apy: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apy_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_credit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_credit_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub calculated_apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_surrender_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_surrender_value_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_limit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_limit_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub day_payment_is_due: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub day_payment_is_due_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub death_benefit: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub death_benefit_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub federal_insurance_status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_account_subtype: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_account_type: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_apy: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_available_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_cash_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_cash_surrender_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_credit_limit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_day_payment_is_due: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_death_benefit: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_holdings_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_interest_rate: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_is_closed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_last_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_last_payment_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_loan_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_matures_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_minimum_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_minimum_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_nickname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_original_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_payment_due_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_payoff_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_started_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_statement_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub feed_total_account_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub holdings_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub holdings_value_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub imported_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub insured_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interest_rate: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interest_rate_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_closed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_closed_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_manual: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment_at_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_amount_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub margin_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub matures_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub matures_on_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_is_managed_by_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_payment_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nickname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nickname_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pay_out_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_due_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_due_at_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payoff_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payoff_balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub premium_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub property_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_on_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub statement_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub statement_balance_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtype: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtype_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub today_ugl_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub today_ugl_percentage: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_account_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_account_value_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_account_value_ugl: ::std::option::Option<f64>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub type_set_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AccountResponse> for AccountResponse {
        fn from(value: &AccountResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountResponse {
        fn default() -> Self {
            Self {
                account_number: Default::default(),
                account_number_set_by: Default::default(),
                account_ownership: Default::default(),
                annuity_policy_to_date: Default::default(),
                annuity_provider: Default::default(),
                annuity_term_year: Default::default(),
                apr: Default::default(),
                apr_set_by: Default::default(),
                apy: Default::default(),
                apy_set_by: Default::default(),
                available_balance: Default::default(),
                available_balance_set_by: Default::default(),
                available_credit: Default::default(),
                available_credit_set_by: Default::default(),
                balance: Default::default(),
                balance_set_by: Default::default(),
                calculated_apr: Default::default(),
                cash_balance: Default::default(),
                cash_balance_set_by: Default::default(),
                cash_surrender_value: Default::default(),
                cash_surrender_value_set_by: Default::default(),
                created_at: Default::default(),
                credit_limit: Default::default(),
                credit_limit_set_by: Default::default(),
                currency_code: Default::default(),
                currency_code_set_by: Default::default(),
                day_payment_is_due: Default::default(),
                day_payment_is_due_set_by: Default::default(),
                death_benefit: Default::default(),
                death_benefit_set_by: Default::default(),
                federal_insurance_status: Default::default(),
                feed_account_number: Default::default(),
                feed_account_subtype: Default::default(),
                feed_account_type: Default::default(),
                feed_apr: Default::default(),
                feed_apy: Default::default(),
                feed_available_balance: Default::default(),
                feed_balance: Default::default(),
                feed_cash_balance: Default::default(),
                feed_cash_surrender_value: Default::default(),
                feed_credit_limit: Default::default(),
                feed_currency_code: Default::default(),
                feed_day_payment_is_due: Default::default(),
                feed_death_benefit: Default::default(),
                feed_holdings_value: Default::default(),
                feed_interest_rate: Default::default(),
                feed_is_closed: Default::default(),
                feed_last_payment: Default::default(),
                feed_last_payment_at: Default::default(),
                feed_loan_amount: Default::default(),
                feed_matures_on: Default::default(),
                feed_minimum_balance: Default::default(),
                feed_minimum_payment: Default::default(),
                feed_name: Default::default(),
                feed_nickname: Default::default(),
                feed_original_balance: Default::default(),
                feed_payment_due_at: Default::default(),
                feed_payoff_balance: Default::default(),
                feed_routing_number: Default::default(),
                feed_started_on: Default::default(),
                feed_statement_balance: Default::default(),
                feed_total_account_value: Default::default(),
                guid: Default::default(),
                holdings_value: Default::default(),
                holdings_value_set_by: Default::default(),
                id: Default::default(),
                imported_at: Default::default(),
                institution_code: Default::default(),
                institution_guid: Default::default(),
                insured_name: Default::default(),
                interest_rate: Default::default(),
                interest_rate_set_by: Default::default(),
                is_closed: Default::default(),
                is_closed_set_by: Default::default(),
                is_hidden: Default::default(),
                is_manual: Default::default(),
                last_payment: Default::default(),
                last_payment_at: Default::default(),
                last_payment_at_set_by: Default::default(),
                last_payment_set_by: Default::default(),
                loan_amount: Default::default(),
                loan_amount_set_by: Default::default(),
                margin_balance: Default::default(),
                matures_on: Default::default(),
                matures_on_set_by: Default::default(),
                member_guid: Default::default(),
                member_id: Default::default(),
                member_is_managed_by_user: Default::default(),
                metadata: Default::default(),
                minimum_balance: Default::default(),
                minimum_balance_set_by: Default::default(),
                minimum_payment: Default::default(),
                minimum_payment_set_by: Default::default(),
                name: Default::default(),
                name_set_by: Default::default(),
                nickname: Default::default(),
                nickname_set_by: Default::default(),
                original_balance: Default::default(),
                original_balance_set_by: Default::default(),
                pay_out_amount: Default::default(),
                payment_due_at: Default::default(),
                payment_due_at_set_by: Default::default(),
                payoff_balance: Default::default(),
                payoff_balance_set_by: Default::default(),
                premium_amount: Default::default(),
                property_type: Default::default(),
                routing_number: Default::default(),
                started_on: Default::default(),
                started_on_set_by: Default::default(),
                statement_balance: Default::default(),
                statement_balance_set_by: Default::default(),
                subtype: Default::default(),
                subtype_set_by: Default::default(),
                today_ugl_amount: Default::default(),
                today_ugl_percentage: Default::default(),
                total_account_value: Default::default(),
                total_account_value_set_by: Default::default(),
                total_account_value_ugl: Default::default(),
                type_: Default::default(),
                type_set_by: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`AccountResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/AccountResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account: ::std::option::Option<AccountResponse>,
    }

    impl ::std::convert::From<&AccountResponseBody> for AccountResponseBody {
        fn from(value: &AccountResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountResponseBody {
        fn default() -> Self {
            Self {
                account: Default::default(),
            }
        }
    }

    ///`AccountUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_subtype": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "PERSONAL"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "account_type": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "SAVINGS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "apr": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "apy": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "available_balance": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "balance": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "cash_surrender_value": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "credit_limit": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "currency_code": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "death_benefit": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "interest_rate": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "is_business": {
    ///      "description": "Can be updated for manual accounts and aggregated
    /// accounts.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_closed": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_hidden": {
    ///      "description": "Can be updated for manual accounts and aggregated
    /// accounts.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "loan_amount": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "metadata": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "Test account 2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nickname": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "Swiss Account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "original_balance": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "property_type": {
    ///      "description": "Can only be updated for manual accounts.",
    ///      "examples": [
    ///        "VEHICLE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_webhook": {
    ///      "description": "If set to true, prevents sending an account webhook
    /// for the update if that webhook type is enabled for you.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountUpdateRequest {
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_subtype: ::std::option::Option<::std::string::String>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apy: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_surrender_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_limit: ::std::option::Option<f64>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub death_benefit: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interest_rate: ::std::option::Option<f64>,
        ///Can be updated for manual accounts and aggregated accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_business: ::std::option::Option<bool>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_closed: ::std::option::Option<bool>,
        ///Can be updated for manual accounts and aggregated accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_amount: ::std::option::Option<f64>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nickname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_balance: ::std::option::Option<f64>,
        ///Can only be updated for manual accounts.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub property_type: ::std::option::Option<::std::string::String>,
        ///If set to true, prevents sending an account webhook for the update
        /// if that webhook type is enabled for you.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_webhook: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&AccountUpdateRequest> for AccountUpdateRequest {
        fn from(value: &AccountUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountUpdateRequest {
        fn default() -> Self {
            Self {
                account_subtype: Default::default(),
                account_type: Default::default(),
                apr: Default::default(),
                apy: Default::default(),
                available_balance: Default::default(),
                balance: Default::default(),
                cash_surrender_value: Default::default(),
                credit_limit: Default::default(),
                currency_code: Default::default(),
                death_benefit: Default::default(),
                interest_rate: Default::default(),
                is_business: Default::default(),
                is_closed: Default::default(),
                is_hidden: Default::default(),
                loan_amount: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
                nickname: Default::default(),
                original_balance: Default::default(),
                property_type: Default::default(),
                skip_webhook: Default::default(),
            }
        }
    }

    ///`AccountUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/AccountUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account: ::std::option::Option<AccountUpdateRequest>,
    }

    impl ::std::convert::From<&AccountUpdateRequestBody> for AccountUpdateRequestBody {
        fn from(value: &AccountUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountUpdateRequestBody {
        fn default() -> Self {
            Self {
                account: Default::default(),
            }
        }
    }

    ///`AccountsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccountsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub accounts: ::std::vec::Vec<AccountResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&AccountsResponseBody> for AccountsResponseBody {
        fn from(value: &AccountsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AccountsResponseBody {
        fn default() -> Self {
            Self {
                accounts: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`AchResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "account_number_last_four": {
    ///      "examples": [
    ///        "1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "account_type": {
    ///      "examples": [
    ///        "CREDIT"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "ach_initiated_at": {
    ///      "examples": [
    ///        "2025-02-13T18:08:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "client_guid": {
    ///      "examples": [
    ///        "CLT-abcd-1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "corrected_account_number": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "corrected_routing_number": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "ACH-d74cb14f-fd0a-449f-991b-e0362a63d9c6"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "client_ach_return_id_1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "institution_guid": {
    ///      "examples": [
    ///        "INS-34r4f44b-cfge-0f6e-3484-21f47e45tfv7"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "investigation_notes": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "processing_errors": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resolution_code": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resolution_detail": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "resolved_status_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "return_account_number": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "return_code": {
    ///      "examples": [
    ///        "R01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "return_notes": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "return_routing_number": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "return_status": {
    ///      "examples": [
    ///        "SUBMITTED"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "returned_at": {
    ///      "examples": [
    ///        "2025-02-13T18:09:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "sec_code": {
    ///      "examples": [
    ///        "PPD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "started_processing_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "submitted_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transaction_amount": {
    ///      "examples": [
    ///        225.84
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ],
    ///      "format": "double"
    ///    },
    ///    "updated_at": {
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AchResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number_last_four: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ach_initiated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub corrected_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub corrected_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub investigation_notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub processing_errors: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resolution_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resolution_detail: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resolved_status_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_notes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub returned_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sec_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_processing_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub submitted_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AchResponse> for AchResponse {
        fn from(value: &AchResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AchResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_number_last_four: Default::default(),
                account_type: Default::default(),
                ach_initiated_at: Default::default(),
                client_guid: Default::default(),
                corrected_account_number: Default::default(),
                corrected_routing_number: Default::default(),
                created_at: Default::default(),
                guid: Default::default(),
                id: Default::default(),
                institution_guid: Default::default(),
                investigation_notes: Default::default(),
                member_guid: Default::default(),
                processing_errors: Default::default(),
                resolution_code: Default::default(),
                resolution_detail: Default::default(),
                resolved_status_at: Default::default(),
                return_account_number: Default::default(),
                return_code: Default::default(),
                return_notes: Default::default(),
                return_routing_number: Default::default(),
                return_status: Default::default(),
                returned_at: Default::default(),
                sec_code: Default::default(),
                started_processing_at: Default::default(),
                submitted_at: Default::default(),
                transaction_amount: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`AchReturnCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "required": [
    ///    "account_guid",
    ///    "id",
    ///    "member_guid",
    ///    "return_code",
    ///    "user_guid"
    ///  ],
    ///  "properties": {
    ///    "account_guid": {
    ///      "description": "The unique identifier for the account associated
    /// with the transaction. Defined by MX.",
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "account_number_last_four": {
    ///      "description": "The last 4 digits of the account number used for
    /// the transaction by the Originating Depository Financial Institution
    /// (ODFI).",
    ///      "examples": [
    ///        "1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ach_initiated_at": {
    ///      "description": "The date and time when the transaction was
    /// initiated by the Originating Depository Financial Institution (ODFI) in
    /// ISO 8601 format without timestamp.",
    ///      "examples": [
    ///        "2025-02-13T18:08:00+00:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "corrected_account_number": {
    ///      "description": "The account number correction reported by the RDFI.
    /// Populate only if the `resolution_code` is `NOTICE_OF_CHANGE`.",
    ///      "type": "string"
    ///    },
    ///    "corrected_routing_number": {
    ///      "description": "The routing number correction reported by the RDFI.
    /// Populate only if the `resolution_code` is `NOTICE_OF_CHANGE`. Must be a
    /// valid 9-digit routing number format.",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Client-defined identifier for this specific return
    /// submission. Allows you to track and reference you requests.",
    ///      "examples": [
    ///        "client_ach_id_1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "member_guid": {
    ///      "description": "The unique identifier for the member associated
    /// with the transaction. Defined by MX.",
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "return_account_number": {
    ///      "description": "Incorrect account number used in the ACH
    /// transaction.",
    ///      "type": "string"
    ///    },
    ///    "return_code": {
    ///      "description": "The associated ACH return code and notice of change
    /// code (for example, R02, R03, R04, R05, R20, NOC). See [Return
    /// Codes](/api-reference/platform-api/reference/ach-return-fields#
    /// return-codes) for a complete list.",
    ///      "examples": [
    ///        "R01"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "return_notes": {
    ///      "description": "Notes that you set to inform MX on internal ACH
    /// processing.",
    ///      "type": "string"
    ///    },
    ///    "return_routing_number": {
    ///      "description": "Incorrect routing number used in the ACH
    /// transaction.",
    ///      "type": "string"
    ///    },
    ///    "returned_at": {
    ///      "description": "The date and time when the return was reported by
    /// the Receiving Financial Depository Institution (RDFI) in ISO 8601 format
    /// without timestamp.",
    ///      "examples": [
    ///        "2025-02-13T18:09:00+00:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "sec_code": {
    ///      "description": "The SEC code (Standard Entry Class Code)a
    /// three-letter code describing how a payment was authorized (for example,
    /// `WEB`). See [SEC
    /// Codes](/api-reference/platform-api/reference/ach-return-fields#
    /// sec-codes) for a complete list.",
    ///      "examples": [
    ///        "PPD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transaction_amount": {
    ///      "description": "The amount of the transaction.",
    ///      "examples": [
    ///        225.84
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "transaction_amount_range": {
    ///      "description": "The transaction amount range, used for impact
    /// assessment.",
    ///      "type": "number"
    ///    },
    ///    "user_guid": {
    ///      "description": "MX-defined identifier for the user associated with
    /// the ACH return.",
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AchReturnCreateRequest {
        ///The unique identifier for the account associated with the
        /// transaction. Defined by MX.
        pub account_guid: ::std::string::String,
        ///The last 4 digits of the account number used for the transaction by
        /// the Originating Depository Financial Institution (ODFI).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number_last_four: ::std::option::Option<::std::string::String>,
        ///The date and time when the transaction was initiated by the
        /// Originating Depository Financial Institution (ODFI) in ISO 8601
        /// format without timestamp.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ach_initiated_at: ::std::option::Option<::std::string::String>,
        ///The account number correction reported by the RDFI. Populate only if
        /// the `resolution_code` is `NOTICE_OF_CHANGE`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub corrected_account_number: ::std::option::Option<::std::string::String>,
        ///The routing number correction reported by the RDFI. Populate only if
        /// the `resolution_code` is `NOTICE_OF_CHANGE`. Must be a valid 9-digit
        /// routing number format.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub corrected_routing_number: ::std::option::Option<::std::string::String>,
        ///Client-defined identifier for this specific return submission.
        /// Allows you to track and reference you requests.
        pub id: ::std::string::String,
        ///The unique identifier for the member associated with the
        /// transaction. Defined by MX.
        pub member_guid: ::std::string::String,
        ///Incorrect account number used in the ACH transaction.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_account_number: ::std::option::Option<::std::string::String>,
        ///The associated ACH return code and notice of change code (for
        /// example, R02, R03, R04, R05, R20, NOC). See [Return
        /// Codes](/api-reference/platform-api/reference/ach-return-fields#
        /// return-codes) for a complete list.
        pub return_code: ::std::string::String,
        ///Notes that you set to inform MX on internal ACH processing.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_notes: ::std::option::Option<::std::string::String>,
        ///Incorrect routing number used in the ACH transaction.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub return_routing_number: ::std::option::Option<::std::string::String>,
        ///The date and time when the return was reported by the Receiving
        /// Financial Depository Institution (RDFI) in ISO 8601 format without
        /// timestamp.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub returned_at: ::std::option::Option<::std::string::String>,
        ///The SEC code (Standard Entry Class Code)a three-letter code
        /// describing how a payment was authorized (for example, `WEB`). See
        /// [SEC Codes](/api-reference/platform-api/reference/ach-return-fields#
        /// sec-codes) for a complete list.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sec_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_amount_range: ::std::option::Option<f64>,
        ///MX-defined identifier for the user associated with the ACH return.
        pub user_guid: ::std::string::String,
    }

    impl ::std::convert::From<&AchReturnCreateRequest> for AchReturnCreateRequest {
        fn from(value: &AchReturnCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`AchReturnCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ach_return": {
    ///      "$ref": "#/components/schemas/ACHReturnCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AchReturnCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ach_return: ::std::option::Option<AchReturnCreateRequest>,
    }

    impl ::std::convert::From<&AchReturnCreateRequestBody> for AchReturnCreateRequestBody {
        fn from(value: &AchReturnCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AchReturnCreateRequestBody {
        fn default() -> Self {
            Self {
                ach_return: Default::default(),
            }
        }
    }

    ///`AchReturnResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ach_return": {
    ///      "$ref": "#/components/schemas/ACHResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AchReturnResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ach_return: ::std::option::Option<AchResponse>,
    }

    impl ::std::convert::From<&AchReturnResponseBody> for AchReturnResponseBody {
        fn from(value: &AchReturnResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AchReturnResponseBody {
        fn default() -> Self {
            Self {
                ach_return: Default::default(),
            }
        }
    }

    ///`AchReturnsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "ach_returns": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ACHResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AchReturnsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub ach_returns: ::std::vec::Vec<AchResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&AchReturnsResponseBody> for AchReturnsResponseBody {
        fn from(value: &AchReturnsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AchReturnsResponseBody {
        fn default() -> Self {
            Self {
                ach_returns: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`AuthorizationCodeRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "scope": {
    ///      "examples": [
    ///        "user-guid:USR-101ad774-288b-44ed-ad16-da87d522ea20 member-guid:MBR-54feffb9-8474-47bd-8442-de003910113a account-guid:ACT-32a64160-582a-4f00-ab34-5f49cc35ed35 read-protected"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthorizationCodeRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scope: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AuthorizationCodeRequest> for AuthorizationCodeRequest {
        fn from(value: &AuthorizationCodeRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AuthorizationCodeRequest {
        fn default() -> Self {
            Self {
                scope: Default::default(),
            }
        }
    }

    ///`AuthorizationCodeRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "authorization_code": {
    ///      "$ref": "#/components/schemas/AuthorizationCodeRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthorizationCodeRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_code: ::std::option::Option<AuthorizationCodeRequest>,
    }

    impl ::std::convert::From<&AuthorizationCodeRequestBody> for AuthorizationCodeRequestBody {
        fn from(value: &AuthorizationCodeRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AuthorizationCodeRequestBody {
        fn default() -> Self {
            Self {
                authorization_code: Default::default(),
            }
        }
    }

    ///`AuthorizationCodeResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "9nN-9D8_4Z3WYazx7-zXfmqsD3jwgL_2W927Sb3otI"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthorizationCodeResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AuthorizationCodeResponse> for AuthorizationCodeResponse {
        fn from(value: &AuthorizationCodeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AuthorizationCodeResponse {
        fn default() -> Self {
            Self {
                code: Default::default(),
            }
        }
    }

    ///`AuthorizationCodeResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "authorization_code": {
    ///      "$ref": "#/components/schemas/AuthorizationCodeResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthorizationCodeResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_code: ::std::option::Option<AuthorizationCodeResponse>,
    }

    impl ::std::convert::From<&AuthorizationCodeResponseBody> for AuthorizationCodeResponseBody {
        fn from(value: &AuthorizationCodeResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AuthorizationCodeResponseBody {
        fn default() -> Self {
            Self {
                authorization_code: Default::default(),
            }
        }
    }

    ///`BudgetCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "category_guid",
    ///    "parent_guid"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Amount of the budget.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "category_guid": {
    ///      "description": "Unique identifier of the category.",
    ///      "examples": [
    ///        "CAT-bd56d35a-a9a7-6e10-66c1-5b9cc1b6c81a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// budget.",
    ///      "examples": [
    ///        "Additional information"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent_guid": {
    ///      "description": "Unique identifier of the parent budget. This is
    /// only required when creating a budget on a sub-category.",
    ///      "examples": [
    ///        "BGT-6be44a91-e105-f68a-4770-8c7c0a5c9778"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_webhook": {
    ///      "description": "When set to true, this parameter will prevent a
    /// webhook from being triggered by the request.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetCreateRequest {
        ///Amount of the budget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<i64>,
        ///Unique identifier of the category.
        pub category_guid: ::std::string::String,
        ///Additional information a partner can store on the budget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///Unique identifier of the parent budget. This is only required when
        /// creating a budget on a sub-category.
        pub parent_guid: ::std::string::String,
        ///When set to true, this parameter will prevent a webhook from being
        /// triggered by the request.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_webhook: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&BudgetCreateRequest> for BudgetCreateRequest {
        fn from(value: &BudgetCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`BudgetCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "budget": {
    ///      "$ref": "#/components/schemas/BudgetCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub budget: ::std::option::Option<BudgetCreateRequest>,
    }

    impl ::std::convert::From<&BudgetCreateRequestBody> for BudgetCreateRequestBody {
        fn from(value: &BudgetCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for BudgetCreateRequestBody {
        fn default() -> Self {
            Self {
                budget: Default::default(),
            }
        }
    }

    ///`BudgetResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "amount": {
    ///      "description": "A goal amount set by the user for a category's
    /// transaction total during a month.",
    ///      "examples": [
    ///        153
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "category_guid": {
    ///      "description": "Unique identifier for the budget category. Defined
    /// by MX.",
    ///      "examples": [
    ///        "CAT-bd56d35a-a9a7-6e10-66c1-5b9cc1b6c81a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "created_at": {
    ///      "description": "Date and time the budget was created, represented
    /// in ISO 8601 format with timestamp.",
    ///      "examples": [
    ///        "2018-10-18T19:51:26+00:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "description": "Unique identifier for the budget. Defined by MX.",
    ///      "examples": [
    ///        "BGT-6ca0e3ef-c65e-4655-8b5a-275a3c19c21d"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_exceeded": {
    ///      "description": "If the budget has been exceeded, this field will be
    /// true. Otherwise, this field will be false.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_off_track": {
    ///      "description": "If the budget is off track, this field will be
    /// true. Otherwise, this field will be false.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// budget.",
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "The name of the budget that is visible to the user
    /// (ie \"Food\", \"Bills\", \"Entertainment\", etc).",
    ///      "examples": [
    ///        "Food & Dining"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "off_track_percentage": {
    ///      "description": "The percentage amount of off track spending.
    /// (Deprecated).",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "parent_guid": {
    ///      "description": "Unique identifier for the parent budget. Defined by
    /// MX.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "percent_spent": {
    ///      "description": "The percentage of a budget that has been spent
    /// during the current calendar month Calculated as the transaction total
    /// divided by the amount and then multiplied by 100.A value of zero will be
    /// returned when `amount` is zero.",
    ///      "examples": [
    ///        1276.34
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "projected_spending": {
    ///      "description": "The projected amount of spending for the budget.",
    ///      "examples": [
    ///        3562.4
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "revision": {
    ///      "description": "The revision number of this budget record.",
    ///      "examples": [
    ///        561
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "transaction_total": {
    ///      "description": "The cumulative amount of all transactions under the
    /// budget.",
    ///      "examples": [
    ///        1952.8
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "description": "Date and time the budget was updated, represented
    /// in ISO 8601 format with timestamp.",
    ///      "examples": [
    ///        "2022-06-14T21:17:11+00:00"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "description": "Unique identifier for the user. Defined by MX.",
    ///      "examples": [
    ///        "USR-11141024-90b3-1bce-cac9-c06ced52ab4c"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        ///Unique identifier for the budget category. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        ///Date and time the budget was created, represented in ISO 8601 format
        /// with timestamp.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        ///Unique identifier for the budget. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        ///If the budget has been exceeded, this field will be true. Otherwise,
        /// this field will be false.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_exceeded: ::std::option::Option<bool>,
        ///If the budget is off track, this field will be true. Otherwise, this
        /// field will be false.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_off_track: ::std::option::Option<bool>,
        ///Additional information a partner can store on the budget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///The name of the budget that is visible to the user (ie "Food",
        /// "Bills", "Entertainment", etc).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The percentage amount of off track spending. (Deprecated).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub off_track_percentage: ::std::option::Option<f64>,
        ///Unique identifier for the parent budget. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent_guid: ::std::option::Option<::std::string::String>,
        ///The percentage of a budget that has been spent during the current
        /// calendar month Calculated as the transaction total divided by the
        /// amount and then multiplied by 100.A value of zero will be returned
        /// when `amount` is zero.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub percent_spent: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub projected_spending: ::std::option::Option<f64>,
        ///The revision number of this budget record.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub revision: ::std::option::Option<i64>,
        ///The cumulative amount of all transactions under the budget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_total: ::std::option::Option<::serde_json::Value>,
        ///Date and time the budget was updated, represented in ISO 8601 format
        /// with timestamp.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::serde_json::Value>,
        ///Unique identifier for the user. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&BudgetResponse> for BudgetResponse {
        fn from(value: &BudgetResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for BudgetResponse {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                category_guid: Default::default(),
                created_at: Default::default(),
                guid: Default::default(),
                is_exceeded: Default::default(),
                is_off_track: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
                off_track_percentage: Default::default(),
                parent_guid: Default::default(),
                percent_spent: Default::default(),
                projected_spending: Default::default(),
                revision: Default::default(),
                transaction_total: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`BudgetResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "budget": {
    ///      "$ref": "#/components/schemas/BudgetResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub budget: ::std::option::Option<BudgetResponse>,
    }

    impl ::std::convert::From<&BudgetResponseBody> for BudgetResponseBody {
        fn from(value: &BudgetResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for BudgetResponseBody {
        fn default() -> Self {
            Self {
                budget: Default::default(),
            }
        }
    }

    ///`BudgetUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Amount of the budget.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// budget.",
    ///      "examples": [
    ///        "Additional information"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_webhook": {
    ///      "description": "When set to true, this parameter will prevent a
    /// webhook from being triggered by the request.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetUpdateRequest {
        ///Amount of the budget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<i64>,
        ///Additional information a partner can store on the budget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///When set to true, this parameter will prevent a webhook from being
        /// triggered by the request.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_webhook: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&BudgetUpdateRequest> for BudgetUpdateRequest {
        fn from(value: &BudgetUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for BudgetUpdateRequest {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                metadata: Default::default(),
                skip_webhook: Default::default(),
            }
        }
    }

    ///`BudgetUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "budget": {
    ///      "$ref": "#/components/schemas/BudgetUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BudgetUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub budget: ::std::option::Option<BudgetUpdateRequest>,
    }

    impl ::std::convert::From<&BudgetUpdateRequestBody> for BudgetUpdateRequestBody {
        fn from(value: &BudgetUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for BudgetUpdateRequestBody {
        fn default() -> Self {
            Self {
                budget: Default::default(),
            }
        }
    }

    ///`CategoriesResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "categories": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CategoryResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoriesResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub categories: ::std::vec::Vec<CategoryResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&CategoriesResponseBody> for CategoriesResponseBody {
        fn from(value: &CategoriesResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CategoriesResponseBody {
        fn default() -> Self {
            Self {
                categories: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`CategoryCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "parent_guid"
    ///  ],
    ///  "properties": {
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Online Shopping"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent_guid": {
    ///      "examples": [
    ///        "CAT-aad51b46-d6f7-3da5-fd6e-492328b3023f"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoryCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
        pub parent_guid: ::std::string::String,
    }

    impl ::std::convert::From<&CategoryCreateRequest> for CategoryCreateRequest {
        fn from(value: &CategoryCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`CategoryCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "category": {
    ///      "$ref": "#/components/schemas/CategoryCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoryCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<CategoryCreateRequest>,
    }

    impl ::std::convert::From<&CategoryCreateRequestBody> for CategoryCreateRequestBody {
        fn from(value: &CategoryCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CategoryCreateRequestBody {
        fn default() -> Self {
            Self {
                category: Default::default(),
            }
        }
    }

    ///`CategoryResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "created_at": {
    ///      "description": "Category creation date-time.",
    ///      "examples": [
    ///        "2015-04-13T18:01:23.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_default": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_income": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Auto Insurance"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "parent_guid": {
    ///      "examples": [
    ///        "CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2015-05-13T18:01:23.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoryResponse {
        ///Category creation date-time.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_default: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_income: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CategoryResponse> for CategoryResponse {
        fn from(value: &CategoryResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CategoryResponse {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                guid: Default::default(),
                is_default: Default::default(),
                is_income: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
                parent_guid: Default::default(),
                updated_at: Default::default(),
            }
        }
    }

    ///`CategoryResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "category": {
    ///      "$ref": "#/components/schemas/CategoryResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoryResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<CategoryResponse>,
    }

    impl ::std::convert::From<&CategoryResponseBody> for CategoryResponseBody {
        fn from(value: &CategoryResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CategoryResponseBody {
        fn default() -> Self {
            Self {
                category: Default::default(),
            }
        }
    }

    ///`CategoryUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Web shopping"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoryUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CategoryUpdateRequest> for CategoryUpdateRequest {
        fn from(value: &CategoryUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CategoryUpdateRequest {
        fn default() -> Self {
            Self {
                metadata: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///`CategoryUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "category": {
    ///      "$ref": "#/components/schemas/CategoryUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CategoryUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<CategoryUpdateRequest>,
    }

    impl ::std::convert::From<&CategoryUpdateRequestBody> for CategoryUpdateRequestBody {
        fn from(value: &CategoryUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CategoryUpdateRequestBody {
        fn default() -> Self {
            Self {
                category: Default::default(),
            }
        }
    }

    ///`ChallengeResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "field_name": {
    ///      "examples": [
    ///        "Who is this guy?"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "CRD-ce76d2e3-86bd-ec4a-ec52-eb53b5194bf5"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "image_data": {
    ///      "examples": [
    ///        "Who is this guy?"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "image_options": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ImageOptionResponse"
    ///      }
    ///    },
    ///    "label": {
    ///      "examples": [
    ///        "Who is this guy?"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "options": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OptionResponse"
    ///      }
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "IMAGE_DATA"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChallengeResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub field_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub image_options: ::std::vec::Vec<ImageOptionResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub label: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub options: ::std::vec::Vec<OptionResponse>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ChallengeResponse> for ChallengeResponse {
        fn from(value: &ChallengeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ChallengeResponse {
        fn default() -> Self {
            Self {
                field_name: Default::default(),
                guid: Default::default(),
                image_data: Default::default(),
                image_options: Default::default(),
                label: Default::default(),
                options: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`ChallengesResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "challenges": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ChallengeResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ChallengesResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub challenges: ::std::vec::Vec<ChallengeResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&ChallengesResponseBody> for ChallengesResponseBody {
        fn from(value: &ChallengesResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ChallengesResponseBody {
        fn default() -> Self {
            Self {
                challenges: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`ConnectWidgetRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "client_redirect_url": {
    ///      "examples": [
    ///        "https://{yoursite.com}"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "color_scheme": {
    ///      "examples": [
    ///        "light"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "current_institution_code": {
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "current_member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "disable_background_agg": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "disable_institution_search": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enable_app2app": {
    ///      "description": "This indicates whether OAuth app2app behavior is
    /// enabled for institutions that support it. Defaults to `true`. When set
    /// to `false`, the widget will **not** direct the end user to the
    /// institution's mobile application. This setting is not persistent. This
    /// setting currently only affects Chase institutions.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "include_identity": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "include_transactions": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_mobile_webview": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "mode": {
    ///      "examples": [
    ///        "aggregation"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "oauth_referral_source": {
    ///      "examples": [
    ///        "BROWSER"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ui_message_version": {
    ///      "examples": [
    ///        4
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "ui_message_webview_url_scheme": {
    ///      "type": "string"
    ///    },
    ///    "update_credentials": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectWidgetRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_redirect_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub color_scheme: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_institution_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub disable_background_agg: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub disable_institution_search: ::std::option::Option<bool>,
        ///This indicates whether OAuth app2app behavior is enabled for
        /// institutions that support it. Defaults to `true`. When set to
        /// `false`, the widget will **not** direct the end user to the
        /// institution's mobile application. This setting is not persistent.
        /// This setting currently only affects Chase institutions.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enable_app2app: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub include_identity: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub include_transactions: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_mobile_webview: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub oauth_referral_source: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ui_message_version: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ui_message_webview_url_scheme: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub update_credentials: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&ConnectWidgetRequest> for ConnectWidgetRequest {
        fn from(value: &ConnectWidgetRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ConnectWidgetRequest {
        fn default() -> Self {
            Self {
                client_redirect_url: Default::default(),
                color_scheme: Default::default(),
                current_institution_code: Default::default(),
                current_member_guid: Default::default(),
                disable_background_agg: Default::default(),
                disable_institution_search: Default::default(),
                enable_app2app: Default::default(),
                include_identity: Default::default(),
                include_transactions: Default::default(),
                is_mobile_webview: Default::default(),
                mode: Default::default(),
                oauth_referral_source: Default::default(),
                ui_message_version: Default::default(),
                ui_message_webview_url_scheme: Default::default(),
                update_credentials: Default::default(),
            }
        }
    }

    ///`ConnectWidgetRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "config": {
    ///      "$ref": "#/components/schemas/ConnectWidgetRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectWidgetRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub config: ::std::option::Option<ConnectWidgetRequest>,
    }

    impl ::std::convert::From<&ConnectWidgetRequestBody> for ConnectWidgetRequestBody {
        fn from(value: &ConnectWidgetRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ConnectWidgetRequestBody {
        fn default() -> Self {
            Self {
                config: Default::default(),
            }
        }
    }

    ///`ConnectWidgetResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "connect_widget_url": {
    ///      "examples": [
    ///        "https://int-widgets.moneydesktop.com/md/connect/jb1rA14m85tw2lyvpgfx4gc6d3Z8z8Ayb8"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectWidgetResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connect_widget_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ConnectWidgetResponse> for ConnectWidgetResponse {
        fn from(value: &ConnectWidgetResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ConnectWidgetResponse {
        fn default() -> Self {
            Self {
                connect_widget_url: Default::default(),
                guid: Default::default(),
            }
        }
    }

    ///`ConnectWidgetResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "user": {
    ///      "$ref": "#/components/schemas/ConnectWidgetResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConnectWidgetResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user: ::std::option::Option<ConnectWidgetResponse>,
    }

    impl ::std::convert::From<&ConnectWidgetResponseBody> for ConnectWidgetResponseBody {
        fn from(value: &ConnectWidgetResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ConnectWidgetResponseBody {
        fn default() -> Self {
            Self {
                user: Default::default(),
            }
        }
    }

    ///`CredentialRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "CRD-27d0edb8-1d50-5b90-bcbc-be270ca42b9f"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "value": {
    ///      "examples": [
    ///        "password"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CredentialRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CredentialRequest> for CredentialRequest {
        fn from(value: &CredentialRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CredentialRequest {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                value: Default::default(),
            }
        }
    }

    ///`CredentialResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "display_order": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "field_name": {
    ///      "examples": [
    ///        "LOGIN"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "field_type": {
    ///      "examples": [
    ///        "TEXT"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "CRD-1ec152cd-e628-e81a-e852-d1e7104624da"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "label": {
    ///      "examples": [
    ///        "Username"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "TEXT"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CredentialResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_order: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub field_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub field_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub label: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CredentialResponse> for CredentialResponse {
        fn from(value: &CredentialResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CredentialResponse {
        fn default() -> Self {
            Self {
                display_order: Default::default(),
                field_name: Default::default(),
                field_type: Default::default(),
                guid: Default::default(),
                label: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`CredentialsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "credentials": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CredentialResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CredentialsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub credentials: ::std::vec::Vec<CredentialResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&CredentialsResponseBody> for CredentialsResponseBody {
        fn from(value: &CredentialsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CredentialsResponseBody {
        fn default() -> Self {
            Self {
                credentials: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`CreditCardProduct`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "annual_fee": {
    ///      "examples": [
    ///        45
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "duration_of_introductory_rate_on_balance_transfer": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "duration_of_introductory_rate_on_purchases": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "CCA-b5bcd822-6d01-4e23-b8d6-846a225e714a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "has_cashback_rewards": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "has_other_rewards": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "has_travel_rewards": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "has_zero_introductory_annual_fee": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "has_zero_percent_introductory_rate": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "has_zero_percent_introductory_rate_on_balance_transfer": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_accepting_applicants": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_active_credit_card_product": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_small_business_card": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Chase Credit Card"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreditCardProduct {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub annual_fee: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub duration_of_introductory_rate_on_balance_transfer: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub duration_of_introductory_rate_on_purchases: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_cashback_rewards: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_other_rewards: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_travel_rewards: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_zero_introductory_annual_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_zero_percent_introductory_rate: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_zero_percent_introductory_rate_on_balance_transfer: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_accepting_applicants: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_active_credit_card_product: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_small_business_card: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CreditCardProduct> for CreditCardProduct {
        fn from(value: &CreditCardProduct) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreditCardProduct {
        fn default() -> Self {
            Self {
                annual_fee: Default::default(),
                duration_of_introductory_rate_on_balance_transfer: Default::default(),
                duration_of_introductory_rate_on_purchases: Default::default(),
                guid: Default::default(),
                has_cashback_rewards: Default::default(),
                has_other_rewards: Default::default(),
                has_travel_rewards: Default::default(),
                has_zero_introductory_annual_fee: Default::default(),
                has_zero_percent_introductory_rate: Default::default(),
                has_zero_percent_introductory_rate_on_balance_transfer: Default::default(),
                is_accepting_applicants: Default::default(),
                is_active_credit_card_product: Default::default(),
                is_small_business_card: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///`CreditCardProductResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "credit_card_product": {
    ///      "$ref": "#/components/schemas/CreditCardProduct"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreditCardProductResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_card_product: ::std::option::Option<CreditCardProduct>,
    }

    impl ::std::convert::From<&CreditCardProductResponse> for CreditCardProductResponse {
        fn from(value: &CreditCardProductResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreditCardProductResponse {
        fn default() -> Self {
            Self {
                credit_card_product: Default::default(),
            }
        }
    }

    ///`EnhanceTransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        21.33
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "categorized_by": {
    ///      "examples": [
    ///        13
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "category": {
    ///      "examples": [
    ///        "Rental Car & Taxi"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-9588eaad-90a4-bb5c-66c8-1812503d0db8"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "described_by": {
    ///      "examples": [
    ///        6
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Uber"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "extended_transaction_type": {
    ///      "examples": [
    ///        "partner_transaction_type"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "ID-123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_bill_pay": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_direct_deposit": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_expense": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_fee": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_income": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_international": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_overdraft_fee": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_payroll_advance": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_subscription": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "Additional-information*on_transaction"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_category_code": {
    ///      "examples": [
    ///        4121
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-14f25b63-ef47-a38e-b2b6-d02b280b6e4e"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_location_guid": {
    ///      "examples": [
    ///        "MCL-00024e59-18b5-4d79-b879-2a7896726fea"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "original_description": {
    ///      "examples": [
    ///        "ubr* pending.uber.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnhanceTransactionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub categorized_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub described_by: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extended_transaction_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_bill_pay: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_direct_deposit: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_expense: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_income: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_overdraft_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_payroll_advance: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_subscription: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_description: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EnhanceTransactionResponse> for EnhanceTransactionResponse {
        fn from(value: &EnhanceTransactionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EnhanceTransactionResponse {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                categorized_by: Default::default(),
                category: Default::default(),
                category_guid: Default::default(),
                described_by: Default::default(),
                description: Default::default(),
                extended_transaction_type: Default::default(),
                id: Default::default(),
                is_bill_pay: Default::default(),
                is_direct_deposit: Default::default(),
                is_expense: Default::default(),
                is_fee: Default::default(),
                is_income: Default::default(),
                is_international: Default::default(),
                is_overdraft_fee: Default::default(),
                is_payroll_advance: Default::default(),
                is_subscription: Default::default(),
                memo: Default::default(),
                merchant_category_code: Default::default(),
                merchant_guid: Default::default(),
                merchant_location_guid: Default::default(),
                original_description: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`EnhanceTransactionsRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        21.33
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "ubr* pending.uber.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "extended_transaction_type": {
    ///      "examples": [
    ///        "partner_transaction_type"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "ID-123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "Additional-information*on_transaction"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "merchant_category_code": {
    ///      "examples": [
    ///        4121
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnhanceTransactionsRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        pub description: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extended_transaction_type: ::std::option::Option<::std::string::String>,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EnhanceTransactionsRequest> for EnhanceTransactionsRequest {
        fn from(value: &EnhanceTransactionsRequest) -> Self {
            value.clone()
        }
    }

    ///`EnhanceTransactionsRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EnhanceTransactionsRequest"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnhanceTransactionsRequestBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transactions: ::std::vec::Vec<EnhanceTransactionsRequest>,
    }

    impl ::std::convert::From<&EnhanceTransactionsRequestBody> for EnhanceTransactionsRequestBody {
        fn from(value: &EnhanceTransactionsRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EnhanceTransactionsRequestBody {
        fn default() -> Self {
            Self {
                transactions: Default::default(),
            }
        }
    }

    ///`EnhanceTransactionsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EnhanceTransactionResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnhanceTransactionsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transactions: ::std::vec::Vec<EnhanceTransactionResponse>,
    }

    impl ::std::convert::From<&EnhanceTransactionsResponseBody> for EnhanceTransactionsResponseBody {
        fn from(value: &EnhanceTransactionsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EnhanceTransactionsResponseBody {
        fn default() -> Self {
            Self {
                transactions: Default::default(),
            }
        }
    }

    ///`GoalRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_guid",
    ///    "amount",
    ///    "goal_type_name",
    ///    "meta_type_name",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "account_guid": {
    ///      "description": "Unique identifier of the account for the goal.",
    ///      "examples": [
    ///        "ACT-4e431124-4a29-abf9-f059-ab232ac14dbf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "description": "Amount of the goal.",
    ///      "examples": [
    ///        4500.5
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "completed_at": {
    ///      "description": "Date and time the goal was completed.",
    ///      "examples": [
    ///        "2015-06-19T10:37:04-06:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "goal_type_name": {
    ///      "description": "The goal type.",
    ///      "examples": [
    ///        "PAYOFF"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "has_been_spent": {
    ///      "description": "Determines if the goal has been spent.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_complete": {
    ///      "description": "Determines if the goal is complete.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "meta_type_name": {
    ///      "description": "The category of the goal.",
    ///      "examples": [
    ///        "VACATION"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// goal.",
    ///      "examples": [
    ///        "Additional information"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the goal.",
    ///      "examples": [
    ///        "Save for Europe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "position": {
    ///      "description": "The priority of the goal in relation to multiple
    /// goals.",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "targeted_to_complete_at": {
    ///      "description": "Date and time the goal is to complete. Intended for
    /// users to set their own goal completion dates.",
    ///      "examples": [
    ///        "2026-12-08 00:00:00.000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GoalRequest {
        ///Unique identifier of the account for the goal.
        pub account_guid: ::std::string::String,
        pub amount: f64,
        ///Date and time the goal was completed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::std::string::String>,
        ///The goal type.
        pub goal_type_name: ::std::string::String,
        ///Determines if the goal has been spent.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_spent: ::std::option::Option<bool>,
        ///Determines if the goal is complete.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_complete: ::std::option::Option<bool>,
        ///The category of the goal.
        pub meta_type_name: ::std::string::String,
        ///Additional information a partner can store on the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///The name of the goal.
        pub name: ::std::string::String,
        ///The priority of the goal in relation to multiple goals.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub position: ::std::option::Option<i64>,
        ///Date and time the goal is to complete. Intended for users to set
        /// their own goal completion dates.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub targeted_to_complete_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GoalRequest> for GoalRequest {
        fn from(value: &GoalRequest) -> Self {
            value.clone()
        }
    }

    ///`GoalRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "goal": {
    ///      "$ref": "#/components/schemas/GoalRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GoalRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goal: ::std::option::Option<GoalRequest>,
    }

    impl ::std::convert::From<&GoalRequestBody> for GoalRequestBody {
        fn from(value: &GoalRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GoalRequestBody {
        fn default() -> Self {
            Self {
                goal: Default::default(),
            }
        }
    }

    ///`GoalResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "account_guid": {
    ///      "description": "Unique identifier of the account for the goal.",
    ///      "examples": [
    ///        "ACT-4e431124-4a29-abf9-f059-ab232ac14dbf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "description": "Amount of the goal.",
    ///      "examples": [
    ///        4500
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "completed_at": {
    ///      "description": "Date and time the goal was completed.",
    ///      "examples": [
    ///        "2015-06-19T10:37:04-06:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "current_amount": {
    ///      "description": "The current amount of the goal.",
    ///      "examples": [
    ///        1651.27
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "goal_type_name": {
    ///      "description": "The goal type.",
    ///      "examples": [
    ///        "PAYOFF"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "description": "Unique identifier for the goal. Defined by MX.",
    ///      "examples": [
    ///        "GOL-f223463-4355-48d0-rce7-fe2rb345617c"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "has_been_spent": {
    ///      "description": "Determines if the goal has been spent.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_complete": {
    ///      "description": "Determines if the goal is complete.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "meta_type_name": {
    ///      "description": "The category of the goal.",
    ///      "examples": [
    ///        "VACATION"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// goal.",
    ///      "examples": [
    ///        "Additional information"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the goal.",
    ///      "examples": [
    ///        "Save for Europe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "position": {
    ///      "description": "The priority of the goal in relation to multiple
    /// goals.",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "projected_to_complete_at": {
    ///      "description": "Date and time the goal is projected to be
    /// completed.",
    ///      "examples": [
    ///        "2022-06-14T16:03:53-00:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "targeted_to_complete_at": {
    ///      "description": "Date and time the goal is to complete. Intended for
    /// users to set their own goal completion dates.",
    ///      "examples": [
    ///        "2026-12-08 00:00:00.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "track_type_name": {
    ///      "examples": [
    ///        "Track Type Name"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "description": "The unique identifier for the the user. Defined by
    /// MX.",
    ///      "examples": [
    ///        "USR-11141024-90b3-1bce-cac9-c06ced52ab4c"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GoalResponse {
        ///Unique identifier of the account for the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        ///Date and time the goal was completed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_amount: ::std::option::Option<f64>,
        ///The goal type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goal_type_name: ::std::option::Option<::std::string::String>,
        ///Unique identifier for the goal. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        ///Determines if the goal has been spent.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_spent: ::std::option::Option<bool>,
        ///Determines if the goal is complete.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_complete: ::std::option::Option<bool>,
        ///The category of the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub meta_type_name: ::std::option::Option<::std::string::String>,
        ///Additional information a partner can store on the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///The name of the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The priority of the goal in relation to multiple goals.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub position: ::std::option::Option<i64>,
        ///Date and time the goal is projected to be completed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub projected_to_complete_at: ::std::option::Option<::std::string::String>,
        ///Date and time the goal is to complete. Intended for users to set
        /// their own goal completion dates.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub targeted_to_complete_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub track_type_name: ::std::option::Option<::std::string::String>,
        ///The unique identifier for the the user. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GoalResponse> for GoalResponse {
        fn from(value: &GoalResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GoalResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                amount: Default::default(),
                completed_at: Default::default(),
                current_amount: Default::default(),
                goal_type_name: Default::default(),
                guid: Default::default(),
                has_been_spent: Default::default(),
                is_complete: Default::default(),
                meta_type_name: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
                position: Default::default(),
                projected_to_complete_at: Default::default(),
                targeted_to_complete_at: Default::default(),
                track_type_name: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`GoalResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "goal": {
    ///      "$ref": "#/components/schemas/GoalResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GoalResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goal: ::std::option::Option<GoalResponse>,
    }

    impl ::std::convert::From<&GoalResponseBody> for GoalResponseBody {
        fn from(value: &GoalResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GoalResponseBody {
        fn default() -> Self {
            Self {
                goal: Default::default(),
            }
        }
    }

    ///`GoalsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "account_guid": {
    ///      "description": "Unique identifier of the account for the goal.",
    ///      "examples": [
    ///        "ACT-4e431124-4a29-abf9-f059-ab232ac14dbf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "description": "Amount of the goal.",
    ///      "examples": [
    ///        4500
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "completed_at": {
    ///      "description": "Date and time the goal was completed.",
    ///      "examples": [
    ///        "2015-06-19T10:37:04-06:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "current_amount": {
    ///      "description": "The current amount of the goal.",
    ///      "examples": [
    ///        1651.27
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "goal_type_name": {
    ///      "description": "The goal type.",
    ///      "examples": [
    ///        "PAYOFF"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "description": "The unique identifier for the goal. Defined by
    /// MX.",
    ///      "examples": [
    ///        "GOL-524ca5db-a2d5-44f3-b048-16de16059024"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "has_been_spent": {
    ///      "description": "Determines if the goal has been spent.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_complete": {
    ///      "description": "Determines if the goal is complete.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "meta_type_name": {
    ///      "description": "The category of the goal.",
    ///      "examples": [
    ///        "VACATION"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// goal.",
    ///      "examples": [
    ///        "Additional information"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the goal.",
    ///      "examples": [
    ///        "Save for Europe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "position": {
    ///      "description": "The priority of the goal in relation to multiple
    /// goals.",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "projected_to_complete_at": {
    ///      "description": "The date on which the project was completed.",
    ///      "examples": [
    ///        "2022-06-14T16:03:53-00:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "targeted_to_complete_at": {
    ///      "examples": [
    ///        "2026-12-08 00:00:00.000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "track_type_name": {
    ///      "examples": [
    ///        "Track Type Name"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "description": "The unique identifier for the the user. Defined by
    /// MX.",
    ///      "examples": [
    ///        "USR-11141024-90b3-1bce-cac9-c06ced52ab4c"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GoalsResponse {
        ///Unique identifier of the account for the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        ///Date and time the goal was completed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_amount: ::std::option::Option<f64>,
        ///The goal type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goal_type_name: ::std::option::Option<::std::string::String>,
        ///The unique identifier for the goal. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        ///Determines if the goal has been spent.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_spent: ::std::option::Option<bool>,
        ///Determines if the goal is complete.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_complete: ::std::option::Option<bool>,
        ///The category of the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub meta_type_name: ::std::option::Option<::std::string::String>,
        ///Additional information a partner can store on the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///The name of the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The priority of the goal in relation to multiple goals.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub position: ::std::option::Option<i64>,
        ///The date on which the project was completed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub projected_to_complete_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub targeted_to_complete_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub track_type_name: ::std::option::Option<::std::string::String>,
        ///The unique identifier for the the user. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GoalsResponse> for GoalsResponse {
        fn from(value: &GoalsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GoalsResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                amount: Default::default(),
                completed_at: Default::default(),
                current_amount: Default::default(),
                goal_type_name: Default::default(),
                guid: Default::default(),
                has_been_spent: Default::default(),
                is_complete: Default::default(),
                meta_type_name: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
                position: Default::default(),
                projected_to_complete_at: Default::default(),
                targeted_to_complete_at: Default::default(),
                track_type_name: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`GoalsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "goals": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GoalsResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GoalsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub goals: ::std::vec::Vec<GoalsResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&GoalsResponseBody> for GoalsResponseBody {
        fn from(value: &GoalsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for GoalsResponseBody {
        fn default() -> Self {
            Self {
                goals: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`ImageOptionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "data_uri": {
    ///      "examples": [
    ///        "data:image/png;base64,iVBORw0KGgoAAAANSUh ... more image data
    /// ..."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "CRD-ce76d2e3-86bd-ec4a-ec52-eb53b5194bf5"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "label": {
    ///      "examples": [
    ///        "IMAGE_1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "value": {
    ///      "examples": [
    ///        "image_data"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImageOptionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data_uri: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub label: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ImageOptionResponse> for ImageOptionResponse {
        fn from(value: &ImageOptionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ImageOptionResponse {
        fn default() -> Self {
            Self {
                data_uri: Default::default(),
                guid: Default::default(),
                label: Default::default(),
                value: Default::default(),
            }
        }
    }

    ///`InsightResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "active_at": {
    ///      "examples": [
    ///        "2022-01-07T12:00:00Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "client_guid": {
    ///      "examples": [
    ///        "CLT-abcd-1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2022-01-12T18:16:51Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cta_clicked_at": {
    ///      "examples": [
    ///        "2022-01-13T18:13:51Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Gold's Gym charged you $36.71 more this month than normal. Did
    /// you upgrade your service?"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "BET-abcd-1234"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_associated_accounts": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_associated_categories": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_associated_merchants": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_associated_scheduled_payments": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_associated_transactions": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_been_displayed": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_dismissed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "micro_call_to_action": {
    ///      "examples": [
    ///        "Learn more"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "micro_description": {
    ///      "examples": [
    ///        "Netflix charged you $5.00 more this month than normal."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "micro_title": {
    ///      "examples": [
    ///        "Price increase"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "template": {
    ///      "examples": [
    ///        "SubscriptionPriceIncrease"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "title": {
    ///      "examples": [
    ///        "Price increase"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2022-01-12T18:16:51Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-1234-abcd"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_id": {
    ///      "examples": [
    ///        "user-partner-defined-1234"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InsightResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub active_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cta_clicked_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_associated_accounts: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_associated_categories: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_associated_merchants: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_associated_scheduled_payments: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_associated_transactions: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_displayed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_dismissed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub micro_call_to_action: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub micro_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub micro_title: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub template: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub title: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&InsightResponse> for InsightResponse {
        fn from(value: &InsightResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InsightResponse {
        fn default() -> Self {
            Self {
                active_at: Default::default(),
                client_guid: Default::default(),
                created_at: Default::default(),
                cta_clicked_at: Default::default(),
                description: Default::default(),
                guid: Default::default(),
                has_associated_accounts: Default::default(),
                has_associated_categories: Default::default(),
                has_associated_merchants: Default::default(),
                has_associated_scheduled_payments: Default::default(),
                has_associated_transactions: Default::default(),
                has_been_displayed: Default::default(),
                is_dismissed: Default::default(),
                micro_call_to_action: Default::default(),
                micro_description: Default::default(),
                micro_title: Default::default(),
                template: Default::default(),
                title: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`InsightResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "insight": {
    ///      "$ref": "#/components/schemas/InsightResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InsightResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub insight: ::std::option::Option<InsightResponse>,
    }

    impl ::std::convert::From<&InsightResponseBody> for InsightResponseBody {
        fn from(value: &InsightResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InsightResponseBody {
        fn default() -> Self {
            Self {
                insight: Default::default(),
            }
        }
    }

    ///`InsightUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "has_been_displayed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_dismissed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InsightUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_displayed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_dismissed: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&InsightUpdateRequest> for InsightUpdateRequest {
        fn from(value: &InsightUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InsightUpdateRequest {
        fn default() -> Self {
            Self {
                has_been_displayed: Default::default(),
                is_dismissed: Default::default(),
            }
        }
    }

    ///`InsightUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "insight": {
    ///      "$ref": "#/components/schemas/InsightUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InsightUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub insight: ::std::option::Option<InsightUpdateRequest>,
    }

    impl ::std::convert::From<&InsightUpdateRequestBody> for InsightUpdateRequestBody {
        fn from(value: &InsightUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InsightUpdateRequestBody {
        fn default() -> Self {
            Self {
                insight: Default::default(),
            }
        }
    }

    ///`InsightsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "insights": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InsightResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InsightsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub insights: ::std::vec::Vec<InsightResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&InsightsResponseBody> for InsightsResponseBody {
        fn from(value: &InsightsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InsightsResponseBody {
        fn default() -> Self {
            Self {
                insights: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`InstitutionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "forgot_password_url": {
    ///      "examples": [
    ///        "https://example.url.mxbank.com/forgot-password"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "forgot_username_url": {
    ///      "examples": [
    ///        "https://example.url.mxbank.com/forgot-username"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "instructional_text": {
    ///      "examples": [
    ///        "Some instructional text <a href=\"https://example.url.mxbank.com/instructions\" id=\"instructional_text\">for end users</a>."
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "instructional_text_steps": {
    ///      "description": "An array of instructional steps that may contain
    /// html elements.",
    ///      "examples": [
    ///        [
    ///          "Step 1: Do this.",
    ///          "Step 2: Do that."
    ///        ]
    ///      ],
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "is_disabled_by_client": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "iso_country_code": {
    ///      "examples": [
    ///        "US"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "medium_logo_url": {
    ///      "examples": [
    ///        "https://content.moneydesktop.com/storage/MD_Assets/Ipad%20Logos/100x100/default_100x100.png"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "MX Bank"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "small_logo_url": {
    ///      "examples": [
    ///        "https://content.moneydesktop.com/storage/MD_Assets/Ipad%20Logos/50x50/default_50x50.png"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "supports_account_identification": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "supports_account_statement": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "supports_account_verification": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "supports_oauth": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "supports_tax_document": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "supports_transaction_history": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "trouble_signing_in_url": {
    ///      "examples": [
    ///        "https://example.url.mxbank.com/login-trouble"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "url": {
    ///      "examples": [
    ///        "https://www.mxbank.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstitutionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub forgot_password_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub forgot_username_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub instructional_text: ::std::option::Option<::std::string::String>,
        ///An array of instructional steps that may contain html elements.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub instructional_text_steps: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_disabled_by_client: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iso_country_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub medium_logo_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub small_logo_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supports_account_identification: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supports_account_statement: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supports_account_verification: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supports_oauth: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supports_tax_document: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub supports_transaction_history: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub trouble_signing_in_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InstitutionResponse> for InstitutionResponse {
        fn from(value: &InstitutionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InstitutionResponse {
        fn default() -> Self {
            Self {
                code: Default::default(),
                forgot_password_url: Default::default(),
                forgot_username_url: Default::default(),
                instructional_text: Default::default(),
                instructional_text_steps: Default::default(),
                is_disabled_by_client: Default::default(),
                iso_country_code: Default::default(),
                medium_logo_url: Default::default(),
                name: Default::default(),
                small_logo_url: Default::default(),
                supports_account_identification: Default::default(),
                supports_account_statement: Default::default(),
                supports_account_verification: Default::default(),
                supports_oauth: Default::default(),
                supports_tax_document: Default::default(),
                supports_transaction_history: Default::default(),
                trouble_signing_in_url: Default::default(),
                url: Default::default(),
            }
        }
    }

    ///`InstitutionResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "institution": {
    ///      "$ref": "#/components/schemas/InstitutionResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstitutionResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution: ::std::option::Option<InstitutionResponse>,
    }

    impl ::std::convert::From<&InstitutionResponseBody> for InstitutionResponseBody {
        fn from(value: &InstitutionResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InstitutionResponseBody {
        fn default() -> Self {
            Self {
                institution: Default::default(),
            }
        }
    }

    ///`InstitutionsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "institutions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InstitutionResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstitutionsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub institutions: ::std::vec::Vec<InstitutionResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&InstitutionsResponseBody> for InstitutionsResponseBody {
        fn from(value: &InstitutionsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InstitutionsResponseBody {
        fn default() -> Self {
            Self {
                institutions: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`InvestmentHoldingResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "cost_basis": {
    ///      "examples": [
    ///        827
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "coupon_yield": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2015-04-13T18:01:23.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "current_price": {
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "current_price_as_of": {
    ///      "examples": [
    ///        "2023-11-06T00:00:00Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "daily_change": {
    ///      "examples": [
    ///        2.5
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Guggenheim Defensive Equity ETF"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "expiration": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "face_value": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "frequency": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "HOL-d65683e8-9eab-26bb-bcfd-ced159c9abe2"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "holding_type": {
    ///      "examples": [
    ///        "MUTUAL_FUND"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "issue_date": {
    ///      "examples": [
    ///        "2015-08-15"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "market_value": {
    ///      "examples": [
    ///        989.5
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "maturity_date": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "percentage_change": {
    ///      "examples": [
    ///        0.2
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "purchase_price": {
    ///      "examples": [
    ///        26.3
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "put_or_call": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "quantity": {
    ///      "examples": [
    ///        "5000.0"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "rate": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "strike_price": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "symbol": {
    ///      "examples": [
    ///        "DEF"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "term": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "term_unit": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "today_ugl_amount": {
    ///      "examples": [
    ///        200
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "today_ugl_percentage": {
    ///      "examples": [
    ///        0.27
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "total_ugl_amount": {
    ///      "examples": [
    ///        20000
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "total_ugl_percentage": {
    ///      "examples": [
    ///        26.67
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "unvested_quantity": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "unvested_value": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-743e5d7f-1116-28fa-5de1-d3ba02e41d8d"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "vested_quantity": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "vested_value": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "vesting_end_date": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "vesting_start_date": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvestmentHoldingResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cost_basis: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub coupon_yield: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_price: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_price_as_of: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub daily_change: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expiration: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub face_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub frequency: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub holding_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub issue_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub market_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub maturity_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub percentage_change: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub purchase_price: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub put_or_call: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub quantity: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rate: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub strike_price: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub symbol: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub term: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub term_unit: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub today_ugl_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub today_ugl_percentage: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_ugl_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_ugl_percentage: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unvested_quantity: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unvested_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vested_quantity: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vested_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vesting_end_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vesting_start_date: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InvestmentHoldingResponse> for InvestmentHoldingResponse {
        fn from(value: &InvestmentHoldingResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InvestmentHoldingResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                cost_basis: Default::default(),
                coupon_yield: Default::default(),
                created_at: Default::default(),
                currency_code: Default::default(),
                current_price: Default::default(),
                current_price_as_of: Default::default(),
                daily_change: Default::default(),
                description: Default::default(),
                expiration: Default::default(),
                face_value: Default::default(),
                frequency: Default::default(),
                guid: Default::default(),
                holding_type: Default::default(),
                issue_date: Default::default(),
                market_value: Default::default(),
                maturity_date: Default::default(),
                percentage_change: Default::default(),
                purchase_price: Default::default(),
                put_or_call: Default::default(),
                quantity: Default::default(),
                rate: Default::default(),
                strike_price: Default::default(),
                symbol: Default::default(),
                term: Default::default(),
                term_unit: Default::default(),
                today_ugl_amount: Default::default(),
                today_ugl_percentage: Default::default(),
                total_ugl_amount: Default::default(),
                total_ugl_percentage: Default::default(),
                unvested_quantity: Default::default(),
                unvested_value: Default::default(),
                user_guid: Default::default(),
                vested_quantity: Default::default(),
                vested_value: Default::default(),
                vesting_end_date: Default::default(),
                vesting_start_date: Default::default(),
            }
        }
    }

    ///`InvestmentHoldingResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "investment_holding": {
    ///      "$ref": "#/components/schemas/InvestmentHoldingResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvestmentHoldingResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub investment_holding: ::std::option::Option<InvestmentHoldingResponse>,
    }

    impl ::std::convert::From<&InvestmentHoldingResponseBody> for InvestmentHoldingResponseBody {
        fn from(value: &InvestmentHoldingResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InvestmentHoldingResponseBody {
        fn default() -> Self {
            Self {
                investment_holding: Default::default(),
            }
        }
    }

    ///`InvestmentHoldingsDeactivation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "message": {
    ///      "examples": [
    ///        "Successfully deactivated user from billing"
    ///      ]
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        200
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvestmentHoldingsDeactivation {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&InvestmentHoldingsDeactivation> for InvestmentHoldingsDeactivation {
        fn from(value: &InvestmentHoldingsDeactivation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InvestmentHoldingsDeactivation {
        fn default() -> Self {
            Self {
                message: Default::default(),
                status: Default::default(),
            }
        }
    }

    ///`InvestmentHoldingsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "investment_holdings": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InvestmentHoldingResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvestmentHoldingsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub investment_holdings: ::std::vec::Vec<InvestmentHoldingResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&InvestmentHoldingsResponseBody> for InvestmentHoldingsResponseBody {
        fn from(value: &InvestmentHoldingsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InvestmentHoldingsResponseBody {
        fn default() -> Self {
            Self {
                investment_holdings: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`ManagedAccountCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balance",
    ///    "id",
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "account_number": {
    ///      "examples": [
    ///        "5366"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "apr": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "apy": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "available_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "available_credit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "cash_surrender_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "credit_limit": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "day_payment_is_due": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "death_benefit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "1040434698"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest_rate": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "is_closed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_hidden": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "last_payment": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "last_payment_at": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loan_amount": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "matures_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minimum_balance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "minimum_payment": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Test account 2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nickname": {
    ///      "examples": [
    ///        "Swiss Account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "original_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "payment_due_at": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payoff_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        "68899990000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "started_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subtype": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "SAVINGS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedAccountCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apy: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_credit: ::std::option::Option<f64>,
        pub balance: f64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_surrender_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_limit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub day_payment_is_due: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub death_benefit: ::std::option::Option<i64>,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interest_rate: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_closed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub matures_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_payment: ::std::option::Option<f64>,
        pub name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nickname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_due_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payoff_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtype: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&ManagedAccountCreateRequest> for ManagedAccountCreateRequest {
        fn from(value: &ManagedAccountCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`ManagedAccountCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/ManagedAccountCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedAccountCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account: ::std::option::Option<ManagedAccountCreateRequest>,
    }

    impl ::std::convert::From<&ManagedAccountCreateRequestBody> for ManagedAccountCreateRequestBody {
        fn from(value: &ManagedAccountCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedAccountCreateRequestBody {
        fn default() -> Self {
            Self {
                account: Default::default(),
            }
        }
    }

    ///`ManagedAccountUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_number": {
    ///      "examples": [
    ///        "5366"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "apr": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "apy": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "available_balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "available_credit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "balance": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "cash_surrender_value": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "credit_limit": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "day_payment_is_due": {
    ///      "examples": [
    ///        20
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "death_benefit": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "1040434698"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "interest_rate": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "is_closed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_hidden": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "last_payment": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "last_payment_at": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "loan_amount": {
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "matures_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "minimum_balance": {
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "minimum_payment": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Test account 2"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "nickname": {
    ///      "examples": [
    ///        "Swiss Account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "original_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "payment_due_at": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payoff_balance": {
    ///      "examples": [
    ///        10
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        "68899990000000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "started_on": {
    ///      "examples": [
    ///        "2015-10-13T17:57:37.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "subtype": {
    ///      "examples": [
    ///        "NONE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "SAVINGS"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedAccountUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apr: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub apy: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_credit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cash_surrender_value: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub credit_limit: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub day_payment_is_due: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub death_benefit: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub interest_rate: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_closed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_payment_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub matures_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub minimum_payment: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nickname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_due_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payoff_balance: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub started_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subtype: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ManagedAccountUpdateRequest> for ManagedAccountUpdateRequest {
        fn from(value: &ManagedAccountUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedAccountUpdateRequest {
        fn default() -> Self {
            Self {
                account_number: Default::default(),
                apr: Default::default(),
                apy: Default::default(),
                available_balance: Default::default(),
                available_credit: Default::default(),
                balance: Default::default(),
                cash_surrender_value: Default::default(),
                credit_limit: Default::default(),
                currency_code: Default::default(),
                day_payment_is_due: Default::default(),
                death_benefit: Default::default(),
                id: Default::default(),
                interest_rate: Default::default(),
                is_closed: Default::default(),
                is_hidden: Default::default(),
                last_payment: Default::default(),
                last_payment_at: Default::default(),
                loan_amount: Default::default(),
                matures_on: Default::default(),
                metadata: Default::default(),
                minimum_balance: Default::default(),
                minimum_payment: Default::default(),
                name: Default::default(),
                nickname: Default::default(),
                original_balance: Default::default(),
                payment_due_at: Default::default(),
                payoff_balance: Default::default(),
                routing_number: Default::default(),
                started_on: Default::default(),
                subtype: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`ManagedAccountUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/ManagedAccountUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedAccountUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account: ::std::option::Option<ManagedAccountUpdateRequest>,
    }

    impl ::std::convert::From<&ManagedAccountUpdateRequestBody> for ManagedAccountUpdateRequestBody {
        fn from(value: &ManagedAccountUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedAccountUpdateRequestBody {
        fn default() -> Self {
            Self {
                account: Default::default(),
            }
        }
    }

    ///`ManagedMemberCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "institution_code"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "examples": [
    ///        "member123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "institution_code": {
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "MX Bank"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedMemberCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        pub institution_code: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ManagedMemberCreateRequest> for ManagedMemberCreateRequest {
        fn from(value: &ManagedMemberCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`ManagedMemberCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/ManagedMemberCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedMemberCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<ManagedMemberCreateRequest>,
    }

    impl ::std::convert::From<&ManagedMemberCreateRequestBody> for ManagedMemberCreateRequestBody {
        fn from(value: &ManagedMemberCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedMemberCreateRequestBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`ManagedMemberUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "id": {
    ///      "examples": [
    ///        "member123"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "MX Bank"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedMemberUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ManagedMemberUpdateRequest> for ManagedMemberUpdateRequest {
        fn from(value: &ManagedMemberUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedMemberUpdateRequest {
        fn default() -> Self {
            Self {
                id: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///`ManagedMemberUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/ManagedMemberUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedMemberUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<ManagedMemberUpdateRequest>,
    }

    impl ::std::convert::From<&ManagedMemberUpdateRequestBody> for ManagedMemberUpdateRequestBody {
        fn from(value: &ManagedMemberUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedMemberUpdateRequestBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`ManagedTransactionCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "description",
    ///    "posted_at",
    ///    "status",
    ///    "transacted_at",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "61.11"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "category": {
    ///      "examples": [
    ///        "Groceries"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "check_number_string": {
    ///      "examples": [
    ///        "6812"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Whole foods"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "transaction-265abee9-889b-af6a-c69b-25157db2bdd9"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_international": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "latitude": {
    ///      "examples": [
    ///        -43.2075
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "localized_description": {
    ///      "examples": [
    ///        "This is a localized_description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "localized_memo": {
    ///      "examples": [
    ///        "This is a localized_memo"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "longitude": {
    ///      "examples": [
    ///        139.691706
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "This is a memo"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "merchant_category_code": {
    ///      "examples": [
    ///        5411
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-7ed79542-884d-2b1b-dd74-501c5cc9d25b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "merchant_location_guid": {
    ///      "examples": [
    ///        "MCL-00024e59-18b5-4d79-b879-2a7896726fea"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "posted_at": {
    ///      "examples": [
    ///        "2016-10-07T06:00:00.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "POSTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transacted_at": {
    ///      "examples": [
    ///        "2016-10-06T13:00:00.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedTransactionCreateRequest {
        pub amount: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub check_number_string: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        pub description: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub longitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        pub posted_at: ::std::string::String,
        pub status: ::std::string::String,
        pub transacted_at: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&ManagedTransactionCreateRequest> for ManagedTransactionCreateRequest {
        fn from(value: &ManagedTransactionCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`ManagedTransactionCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction": {
    ///      "$ref": "#/components/schemas/ManagedTransactionCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedTransactionCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction: ::std::option::Option<ManagedTransactionCreateRequest>,
    }

    impl ::std::convert::From<&ManagedTransactionCreateRequestBody>
        for ManagedTransactionCreateRequestBody
    {
        fn from(value: &ManagedTransactionCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedTransactionCreateRequestBody {
        fn default() -> Self {
            Self {
                transaction: Default::default(),
            }
        }
    }

    ///`ManagedTransactionUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        "61.11"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "category": {
    ///      "examples": [
    ///        "Groceries"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "check_number_string": {
    ///      "examples": [
    ///        "6812"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Whole foods"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "transaction-265abee9-889b-af6a-c69b-25157db2bdd9"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_international": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "latitude": {
    ///      "examples": [
    ///        -43.2075
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "localized_description": {
    ///      "examples": [
    ///        "This is a localized_description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "localized_memo": {
    ///      "examples": [
    ///        "This is a localized_memo"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "longitude": {
    ///      "examples": [
    ///        139.691706
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "This is a memo"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "merchant_category_code": {
    ///      "examples": [
    ///        5411
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-7ed79542-884d-2b1b-dd74-501c5cc9d25b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "merchant_location_guid": {
    ///      "examples": [
    ///        "MCL-00024e59-18b5-4d79-b879-2a7896726fea"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "posted_at": {
    ///      "examples": [
    ///        "2016-10-07T06:00:00.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "POSTED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transacted_at": {
    ///      "examples": [
    ///        "2016-10-06T13:00:00.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedTransactionUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub check_number_string: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub longitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub posted_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transacted_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ManagedTransactionUpdateRequest> for ManagedTransactionUpdateRequest {
        fn from(value: &ManagedTransactionUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedTransactionUpdateRequest {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                category: Default::default(),
                check_number_string: Default::default(),
                currency_code: Default::default(),
                description: Default::default(),
                id: Default::default(),
                is_international: Default::default(),
                latitude: Default::default(),
                localized_description: Default::default(),
                localized_memo: Default::default(),
                longitude: Default::default(),
                memo: Default::default(),
                merchant_category_code: Default::default(),
                merchant_guid: Default::default(),
                merchant_location_guid: Default::default(),
                metadata: Default::default(),
                posted_at: Default::default(),
                status: Default::default(),
                transacted_at: Default::default(),
                type_: Default::default(),
            }
        }
    }

    ///`ManagedTransactionUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction": {
    ///      "$ref": "#/components/schemas/ManagedTransactionUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ManagedTransactionUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction: ::std::option::Option<ManagedTransactionUpdateRequest>,
    }

    impl ::std::convert::From<&ManagedTransactionUpdateRequestBody>
        for ManagedTransactionUpdateRequestBody
    {
        fn from(value: &ManagedTransactionUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ManagedTransactionUpdateRequestBody {
        fn default() -> Self {
            Self {
                transaction: Default::default(),
            }
        }
    }

    ///`MemberCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "credentials",
    ///    "institution_code"
    ///  ],
    ///  "properties": {
    ///    "background_aggregation_is_disabled": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "credentials": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CredentialRequest"
    ///      }
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "unique_id"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "institution_code": {
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_oauth": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "\\\"credentials_last_refreshed_at\\\": \\\"2015-10-15\\"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_aggregation": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "use_cases": {
    ///      "description": "The use case associated with the member. Valid
    /// values are `PFM` and/or `MONEY_MOVEMENT`. Only set this if you've met
    /// with MX and have opted in to using this field.",
    ///      "examples": [
    ///        [
    ///          "PFM"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "MONEY_MOVEMENT",
    ///          "PFM"
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub background_aggregation_is_disabled: ::std::option::Option<bool>,
        pub credentials: ::std::vec::Vec<CredentialRequest>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        pub institution_code: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_oauth: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_aggregation: ::std::option::Option<bool>,
        ///The use case associated with the member. Valid values are `PFM`
        /// and/or `MONEY_MOVEMENT`. Only set this if you've met with MX and
        /// have opted in to using this field.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub use_cases: ::std::vec::Vec<MemberCreateRequestUseCasesItem>,
    }

    impl ::std::convert::From<&MemberCreateRequest> for MemberCreateRequest {
        fn from(value: &MemberCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`MemberCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "client_redirect_url": {
    ///      "examples": [
    ///        "https://{yoursite.com}"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "enable_app2app": {
    ///      "description": "This indicates whether OAuth app2app behavior is enabled for institutions that support it. Defaults to `true`. When set to `false`, any `oauth_window_uri` generated will **not** direct the end user to the institution's mobile application. This setting is not persistent. This setting currently only affects Chase institutions.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "member": {
    ///      "$ref": "#/components/schemas/MemberCreateRequest"
    ///    },
    ///    "referral_source": {
    ///      "examples": [
    ///        "APP"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ui_message_webview_url_scheme": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_redirect_url: ::std::option::Option<::std::string::String>,
        ///This indicates whether OAuth app2app behavior is enabled for
        /// institutions that support it. Defaults to `true`. When set to
        /// `false`, any `oauth_window_uri` generated will **not** direct the
        /// end user to the institution's mobile application. This setting is
        /// not persistent. This setting currently only affects Chase
        /// institutions.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enable_app2app: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<MemberCreateRequest>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub referral_source: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ui_message_webview_url_scheme: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MemberCreateRequestBody> for MemberCreateRequestBody {
        fn from(value: &MemberCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberCreateRequestBody {
        fn default() -> Self {
            Self {
                client_redirect_url: Default::default(),
                enable_app2app: Default::default(),
                member: Default::default(),
                referral_source: Default::default(),
                ui_message_webview_url_scheme: Default::default(),
            }
        }
    }

    ///`MemberCreateRequestUseCasesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MONEY_MOVEMENT",
    ///    "PFM"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MemberCreateRequestUseCasesItem {
        #[serde(rename = "MONEY_MOVEMENT")]
        MoneyMovement,
        #[serde(rename = "PFM")]
        Pfm,
    }

    impl ::std::convert::From<&Self> for MemberCreateRequestUseCasesItem {
        fn from(value: &MemberCreateRequestUseCasesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MemberCreateRequestUseCasesItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MoneyMovement => f.write_str("MONEY_MOVEMENT"),
                Self::Pfm => f.write_str("PFM"),
            }
        }
    }

    impl ::std::str::FromStr for MemberCreateRequestUseCasesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "MONEY_MOVEMENT" => Ok(Self::MoneyMovement),
                "PFM" => Ok(Self::Pfm),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MemberCreateRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MemberCreateRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MemberCreateRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`MemberElements`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-283132a4-1401-486a-909e-1605f1623d11"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-54feffb9-8474-47bd-8442-de003910113a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-101ad774-288b-44ed-ad16-da87d522ea20"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberElements {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MemberElements> for MemberElements {
        fn from(value: &MemberElements) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberElements {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                member_guid: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`MemberResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "aggregated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:07:57.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "background_aggregation_is_disabled": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "connection_status": {
    ///      "examples": [
    ///        "CONNECTED"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "connection_status_message": {
    ///      "examples": [
    ///        "Connected to MX Bank"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "unique_id"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "institution_code": {
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "institution_guid": {
    ///      "examples": [
    ///        "INST-12345678-90ab-cdef-1234-567890abcdef"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_being_aggregated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_managed_by_user": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_manual": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_oauth": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "\\\"credentials_last_refreshed_at\\\": \\\"2015-10-15\\"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "most_recent_job_detail_code": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "most_recent_job_detail_text": {
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "most_recent_job_guid": {
    ///      "examples": [
    ///        "JOB-12345678-90ab-cdef-1234-567890abcdef"
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "MX Bank"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "needs_updated_credentials": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "oauth_window_uri": {
    ///      "examples": [
    ///        "https://mxbank.mx.com/oauth/authorize?client_id=b8OikQ4Ep3NuSUrQ13DdvFuwpNx-qqoAsJDVAQCyLkQ&redirect_uri=https%3A%2F%2Fint-app.moneydesktop.com%2Foauth%2Fredirect_from&response_type=code&scope=openid&state=d745bd4ee6f0f9c184757f574bcc2df2"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "successfully_aggregated_at": {
    ///      "examples": [
    ///        "2016-10-13T17:57:38.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "use_cases": {
    ///      "description": "The use case associated with the member. Valid
    /// values are `PFM` and/or `MONEY_MOVEMENT`. Only set this if you've met
    /// with MX and have opted in to using this field.",
    ///      "examples": [
    ///        [
    ///          "PFM"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "MONEY_MOVEMENT",
    ///          "PFM"
    ///        ]
    ///      }
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "examples": [
    ///        "user123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub aggregated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub background_aggregation_is_disabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connection_status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connection_status_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_being_aggregated: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_managed_by_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_manual: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_oauth: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub most_recent_job_detail_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub most_recent_job_detail_text: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub most_recent_job_guid: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub needs_updated_credentials: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub oauth_window_uri: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub successfully_aggregated_at: ::std::option::Option<::std::string::String>,
        ///The use case associated with the member. Valid values are `PFM`
        /// and/or `MONEY_MOVEMENT`. Only set this if you've met with MX and
        /// have opted in to using this field.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub use_cases: ::std::vec::Vec<MemberResponseUseCasesItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MemberResponse> for MemberResponse {
        fn from(value: &MemberResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberResponse {
        fn default() -> Self {
            Self {
                aggregated_at: Default::default(),
                background_aggregation_is_disabled: Default::default(),
                connection_status: Default::default(),
                connection_status_message: Default::default(),
                guid: Default::default(),
                id: Default::default(),
                institution_code: Default::default(),
                institution_guid: Default::default(),
                is_being_aggregated: Default::default(),
                is_managed_by_user: Default::default(),
                is_manual: Default::default(),
                is_oauth: Default::default(),
                metadata: Default::default(),
                most_recent_job_detail_code: Default::default(),
                most_recent_job_detail_text: Default::default(),
                most_recent_job_guid: Default::default(),
                name: Default::default(),
                needs_updated_credentials: Default::default(),
                oauth_window_uri: Default::default(),
                successfully_aggregated_at: Default::default(),
                use_cases: Default::default(),
                user_guid: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`MemberResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/MemberResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<MemberResponse>,
    }

    impl ::std::convert::From<&MemberResponseBody> for MemberResponseBody {
        fn from(value: &MemberResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberResponseBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`MemberResponseUseCasesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MONEY_MOVEMENT",
    ///    "PFM"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MemberResponseUseCasesItem {
        #[serde(rename = "MONEY_MOVEMENT")]
        MoneyMovement,
        #[serde(rename = "PFM")]
        Pfm,
    }

    impl ::std::convert::From<&Self> for MemberResponseUseCasesItem {
        fn from(value: &MemberResponseUseCasesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MemberResponseUseCasesItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MoneyMovement => f.write_str("MONEY_MOVEMENT"),
                Self::Pfm => f.write_str("PFM"),
            }
        }
    }

    impl ::std::str::FromStr for MemberResponseUseCasesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "MONEY_MOVEMENT" => Ok(Self::MoneyMovement),
                "PFM" => Ok(Self::Pfm),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MemberResponseUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MemberResponseUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MemberResponseUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`MemberResumeRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "challenges": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CredentialRequest"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberResumeRequest {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub challenges: ::std::vec::Vec<CredentialRequest>,
    }

    impl ::std::convert::From<&MemberResumeRequest> for MemberResumeRequest {
        fn from(value: &MemberResumeRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberResumeRequest {
        fn default() -> Self {
            Self {
                challenges: Default::default(),
            }
        }
    }

    ///`MemberResumeRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/MemberResumeRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberResumeRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<MemberResumeRequest>,
    }

    impl ::std::convert::From<&MemberResumeRequestBody> for MemberResumeRequestBody {
        fn from(value: &MemberResumeRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberResumeRequestBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`MemberStatusResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "aggregated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:07:57.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "challenges": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ChallengeResponse"
    ///      }
    ///    },
    ///    "connection_status": {
    ///      "examples": [
    ///        "CONNECTED"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_processed_account_numbers": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_processed_accounts": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "has_processed_transactions": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_authenticated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_being_aggregated": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "successfully_aggregated_at": {
    ///      "examples": [
    ///        "2016-10-13T17:57:38.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberStatusResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub aggregated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub challenges: ::std::vec::Vec<ChallengeResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connection_status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_processed_account_numbers: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_processed_accounts: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_processed_transactions: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_authenticated: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_being_aggregated: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub successfully_aggregated_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MemberStatusResponse> for MemberStatusResponse {
        fn from(value: &MemberStatusResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberStatusResponse {
        fn default() -> Self {
            Self {
                aggregated_at: Default::default(),
                challenges: Default::default(),
                connection_status: Default::default(),
                guid: Default::default(),
                has_processed_account_numbers: Default::default(),
                has_processed_accounts: Default::default(),
                has_processed_transactions: Default::default(),
                is_authenticated: Default::default(),
                is_being_aggregated: Default::default(),
                successfully_aggregated_at: Default::default(),
            }
        }
    }

    ///`MemberStatusResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/MemberStatusResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberStatusResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<MemberStatusResponse>,
    }

    impl ::std::convert::From<&MemberStatusResponseBody> for MemberStatusResponseBody {
        fn from(value: &MemberStatusResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberStatusResponseBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`MemberUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "background_aggregation_is_disabled": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "credentials": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CredentialRequest"
    ///      }
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "unique_id"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "\\\"credentials_last_refreshed_at\\\": \\\"2015-10-15\\"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_aggregation": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "use_cases": {
    ///      "description": "The use case associated with the member. Valid
    /// values are `PFM` and/or `MONEY_MOVEMENT`. Only set this if you've met
    /// with MX and have opted in to using this field.",
    ///      "examples": [
    ///        [
    ///          "PFM"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "MONEY_MOVEMENT",
    ///          "PFM"
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub background_aggregation_is_disabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub credentials: ::std::vec::Vec<CredentialRequest>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_aggregation: ::std::option::Option<bool>,
        ///The use case associated with the member. Valid values are `PFM`
        /// and/or `MONEY_MOVEMENT`. Only set this if you've met with MX and
        /// have opted in to using this field.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub use_cases: ::std::vec::Vec<MemberUpdateRequestUseCasesItem>,
    }

    impl ::std::convert::From<&MemberUpdateRequest> for MemberUpdateRequest {
        fn from(value: &MemberUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberUpdateRequest {
        fn default() -> Self {
            Self {
                background_aggregation_is_disabled: Default::default(),
                credentials: Default::default(),
                id: Default::default(),
                metadata: Default::default(),
                skip_aggregation: Default::default(),
                use_cases: Default::default(),
            }
        }
    }

    ///`MemberUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/MemberUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MemberUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<MemberUpdateRequest>,
    }

    impl ::std::convert::From<&MemberUpdateRequestBody> for MemberUpdateRequestBody {
        fn from(value: &MemberUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MemberUpdateRequestBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`MemberUpdateRequestUseCasesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MONEY_MOVEMENT",
    ///    "PFM"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MemberUpdateRequestUseCasesItem {
        #[serde(rename = "MONEY_MOVEMENT")]
        MoneyMovement,
        #[serde(rename = "PFM")]
        Pfm,
    }

    impl ::std::convert::From<&Self> for MemberUpdateRequestUseCasesItem {
        fn from(value: &MemberUpdateRequestUseCasesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MemberUpdateRequestUseCasesItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MoneyMovement => f.write_str("MONEY_MOVEMENT"),
                Self::Pfm => f.write_str("PFM"),
            }
        }
    }

    impl ::std::str::FromStr for MemberUpdateRequestUseCasesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "MONEY_MOVEMENT" => Ok(Self::MoneyMovement),
                "PFM" => Ok(Self::Pfm),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MemberUpdateRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MemberUpdateRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MemberUpdateRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`MembersResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "members": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MemberResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MembersResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub members: ::std::vec::Vec<MemberResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&MembersResponseBody> for MembersResponseBody {
        fn from(value: &MembersResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MembersResponseBody {
        fn default() -> Self {
            Self {
                members: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`MerchantLocationResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "city": {
    ///      "examples": [
    ///        "Greenwood Village"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "country": {
    ///      "examples": [
    ///        "US"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2020-04-13 21:05:09.000000000 Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "MCL-00024e59-18b5-4d79-b879-2a7896726fea"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "latitude": {
    ///      "examples": [
    ///        39.5963005
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "longitude": {
    ///      "examples": [
    ///        -104.89158799999998
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-09466f0a-fb58-9d1a-bae2-2af0afbea621"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "phone_number": {
    ///      "examples": [
    ///        "(303) 689-0728"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "postal_code": {
    ///      "examples": [
    ///        "801121436"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "state": {
    ///      "examples": [
    ///        "CO"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "street_address": {
    ///      "examples": [
    ///        "8547 E Arapahoe Rd, Ste 1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2020-04-13 21:05:09.000000000 Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MerchantLocationResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub longitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MerchantLocationResponse> for MerchantLocationResponse {
        fn from(value: &MerchantLocationResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MerchantLocationResponse {
        fn default() -> Self {
            Self {
                city: Default::default(),
                country: Default::default(),
                created_at: Default::default(),
                guid: Default::default(),
                latitude: Default::default(),
                longitude: Default::default(),
                merchant_guid: Default::default(),
                phone_number: Default::default(),
                postal_code: Default::default(),
                state: Default::default(),
                street_address: Default::default(),
                updated_at: Default::default(),
            }
        }
    }

    ///`MerchantLocationResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "merchant_location": {
    ///      "$ref": "#/components/schemas/MerchantLocationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MerchantLocationResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location: ::std::option::Option<MerchantLocationResponse>,
    }

    impl ::std::convert::From<&MerchantLocationResponseBody> for MerchantLocationResponseBody {
        fn from(value: &MerchantLocationResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MerchantLocationResponseBody {
        fn default() -> Self {
            Self {
                merchant_location: Default::default(),
            }
        }
    }

    ///`MerchantResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "created_at": {
    ///      "examples": [
    ///        "2017-04-20T19:30:12.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "MCH-7ed79542-884d-2b1b-dd74-501c5cc9d25b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "logo_url": {
    ///      "examples": [
    ///        "https://s3.amazonaws.com/MD_Assets/merchant_logos/comcast.png"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "Comcast"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2018-09-28T21:13:53.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "website_url": {
    ///      "examples": [
    ///        "https://www.xfinity.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MerchantResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub logo_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub website_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MerchantResponse> for MerchantResponse {
        fn from(value: &MerchantResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MerchantResponse {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                guid: Default::default(),
                logo_url: Default::default(),
                name: Default::default(),
                updated_at: Default::default(),
                website_url: Default::default(),
            }
        }
    }

    ///`MerchantResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "merchant": {
    ///      "$ref": "#/components/schemas/MerchantResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MerchantResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant: ::std::option::Option<MerchantResponse>,
    }

    impl ::std::convert::From<&MerchantResponseBody> for MerchantResponseBody {
        fn from(value: &MerchantResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MerchantResponseBody {
        fn default() -> Self {
            Self {
                merchant: Default::default(),
            }
        }
    }

    ///`MerchantsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "merchants": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MerchantResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MerchantsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub merchants: ::std::vec::Vec<MerchantResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&MerchantsResponseBody> for MerchantsResponseBody {
        fn from(value: &MerchantsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MerchantsResponseBody {
        fn default() -> Self {
            Self {
                merchants: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`MicrodepositElements`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "required": [
    ///    "account_number",
    ///    "account_type",
    ///    "routing_number"
    ///  ],
    ///  "properties": {
    ///    "account_name": {
    ///      "examples": [
    ///        "My test account"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "account_number": {
    ///      "examples": [
    ///        "3331261"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "account_type": {
    ///      "examples": [
    ///        "CHECKING"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "examples": [
    ///        "joshyboy2@example.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "first_name": {
    ///      "examples": [
    ///        "Joshy"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "last_name": {
    ///      "examples": [
    ///        "Grobanne"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        "091000019"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositElements {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_name: ::std::option::Option<::std::string::String>,
        pub account_number: ::std::string::String,
        pub account_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<::std::string::String>,
        pub routing_number: ::std::string::String,
    }

    impl ::std::convert::From<&MicrodepositElements> for MicrodepositElements {
        fn from(value: &MicrodepositElements) -> Self {
            value.clone()
        }
    }

    ///`MicrodepositRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "micro_deposit": {
    ///      "$ref": "#/components/schemas/MicrodepositElements"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub micro_deposit: ::std::option::Option<MicrodepositElements>,
    }

    impl ::std::convert::From<&MicrodepositRequestBody> for MicrodepositRequestBody {
        fn from(value: &MicrodepositRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MicrodepositRequestBody {
        fn default() -> Self {
            Self {
                micro_deposit: Default::default(),
            }
        }
    }

    ///`MicrodepositResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "error_message": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "MIC-09ba578e-8448-4f7f-89e1-b62ff2517edb"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "institution_code": {
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "institution_name": {
    ///      "examples": [
    ///        "MX Bank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "INITIATED"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2023-06-01T19:18:06Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "verified_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub verified_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MicrodepositResponse> for MicrodepositResponse {
        fn from(value: &MicrodepositResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MicrodepositResponse {
        fn default() -> Self {
            Self {
                error_message: Default::default(),
                guid: Default::default(),
                institution_code: Default::default(),
                institution_name: Default::default(),
                status: Default::default(),
                updated_at: Default::default(),
                verified_at: Default::default(),
            }
        }
    }

    ///`MicrodepositResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "micro_deposit": {
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/MicrodepositElements"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/MicrodepositResponse"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub micro_deposit: ::std::vec::Vec<MicrodepositResponseBodyMicroDepositItem>,
    }

    impl ::std::convert::From<&MicrodepositResponseBody> for MicrodepositResponseBody {
        fn from(value: &MicrodepositResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MicrodepositResponseBody {
        fn default() -> Self {
            Self {
                micro_deposit: Default::default(),
            }
        }
    }

    ///`MicrodepositResponseBodyMicroDepositItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MicrodepositElements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/MicrodepositResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositResponseBodyMicroDepositItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_name: ::std::option::Option<::std::string::String>,
        pub account_number: ::std::string::String,
        pub account_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<::std::string::String>,
        pub routing_number: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub verified_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MicrodepositResponseBodyMicroDepositItem>
        for MicrodepositResponseBodyMicroDepositItem
    {
        fn from(value: &MicrodepositResponseBodyMicroDepositItem) -> Self {
            value.clone()
        }
    }

    ///`MicrodepositVerifyRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "deposit_amount_1": {
    ///      "examples": [
    ///        0.09
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "deposit_amount_2": {
    ///      "examples": [
    ///        0.09
    ///      ],
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositVerifyRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deposit_amount_1: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deposit_amount_2: ::std::option::Option<f64>,
    }

    impl ::std::convert::From<&MicrodepositVerifyRequest> for MicrodepositVerifyRequest {
        fn from(value: &MicrodepositVerifyRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MicrodepositVerifyRequest {
        fn default() -> Self {
            Self {
                deposit_amount_1: Default::default(),
                deposit_amount_2: Default::default(),
            }
        }
    }

    ///`MicrodepositVerifyRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "micro_deposit": {
    ///      "$ref": "#/components/schemas/MicrodepositVerifyRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositVerifyRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub micro_deposit: ::std::option::Option<MicrodepositVerifyRequest>,
    }

    impl ::std::convert::From<&MicrodepositVerifyRequestBody> for MicrodepositVerifyRequestBody {
        fn from(value: &MicrodepositVerifyRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MicrodepositVerifyRequestBody {
        fn default() -> Self {
            Self {
                micro_deposit: Default::default(),
            }
        }
    }

    ///`MicrodepositsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "micro_deposits": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MicrodepositResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MicrodepositsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub micro_deposits: ::std::vec::Vec<MicrodepositResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&MicrodepositsResponseBody> for MicrodepositsResponseBody {
        fn from(value: &MicrodepositsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MicrodepositsResponseBody {
        fn default() -> Self {
            Self {
                micro_deposits: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`MonthlyCashFlowProfileRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "goals_contribution": {
    ///      "description": "The monthly dollar amount allocated for goals.",
    ///      "examples": [
    ///        150.01
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "uses_estimated_goals_contribution": {
    ///      "description": "Determines if the user uses estimated goals
    /// contribution.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MonthlyCashFlowProfileRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goals_contribution: ::std::option::Option<f64>,
        ///Determines if the user uses estimated goals contribution.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uses_estimated_goals_contribution: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&MonthlyCashFlowProfileRequest> for MonthlyCashFlowProfileRequest {
        fn from(value: &MonthlyCashFlowProfileRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MonthlyCashFlowProfileRequest {
        fn default() -> Self {
            Self {
                goals_contribution: Default::default(),
                uses_estimated_goals_contribution: Default::default(),
            }
        }
    }

    ///`MonthlyCashFlowProfileRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "institution": {
    ///      "$ref": "#/components/schemas/MonthlyCashFlowProfileRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MonthlyCashFlowProfileRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution: ::std::option::Option<MonthlyCashFlowProfileRequest>,
    }

    impl ::std::convert::From<&MonthlyCashFlowProfileRequestBody>
        for MonthlyCashFlowProfileRequestBody
    {
        fn from(value: &MonthlyCashFlowProfileRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MonthlyCashFlowProfileRequestBody {
        fn default() -> Self {
            Self {
                institution: Default::default(),
            }
        }
    }

    ///`MonthlyCashFlowResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "budgeted_expenses": {
    ///      "description": "The amount of the budgeted expenses for the user.",
    ///      "examples": [
    ///        1000
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "budgeted_income": {
    ///      "description": "The amount of the budgeted income for the user.",
    ///      "examples": [
    ///        1200.12
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "estimated_goals_contribution": {
    ///      "description": "The estimated monthly dollar amount allocated for
    /// goals calculated from income and budgets.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "goals_contribution": {
    ///      "description": "The monthly dollar amount allocated for goals.",
    ///      "examples": [
    ///        150
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "guid": {
    ///      "description": "Unique identifier for the monthly cash flow
    /// profile. Defined by MX.",
    ///      "examples": [
    ///        "MCF-4e431124-4a29-abf9-f059-ab232ac14dbf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "description": "Unique identifier for the user the monthly cash
    /// flow profile is attached to. Defined by MX.",
    ///      "examples": [
    ///        "USR-6c83f63c-efcc-0189-3f14-100f0bad378a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "uses_estimated_goals_contribution": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MonthlyCashFlowResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub budgeted_expenses: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub budgeted_income: ::std::option::Option<f64>,
        ///The estimated monthly dollar amount allocated for goals calculated
        /// from income and budgets.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub estimated_goals_contribution: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goals_contribution: ::std::option::Option<f64>,
        ///Unique identifier for the monthly cash flow profile. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        ///Unique identifier for the user the monthly cash flow profile is
        /// attached to. Defined by MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uses_estimated_goals_contribution: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&MonthlyCashFlowResponse> for MonthlyCashFlowResponse {
        fn from(value: &MonthlyCashFlowResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MonthlyCashFlowResponse {
        fn default() -> Self {
            Self {
                budgeted_expenses: Default::default(),
                budgeted_income: Default::default(),
                estimated_goals_contribution: Default::default(),
                goals_contribution: Default::default(),
                guid: Default::default(),
                user_guid: Default::default(),
                uses_estimated_goals_contribution: Default::default(),
            }
        }
    }

    ///`MonthlyCashFlowResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "monthly_cash_flow_profile": {
    ///      "$ref": "#/components/schemas/MonthlyCashFlowResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MonthlyCashFlowResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub monthly_cash_flow_profile: ::std::option::Option<MonthlyCashFlowResponse>,
    }

    impl ::std::convert::From<&MonthlyCashFlowResponseBody> for MonthlyCashFlowResponseBody {
        fn from(value: &MonthlyCashFlowResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for MonthlyCashFlowResponseBody {
        fn default() -> Self {
            Self {
                monthly_cash_flow_profile: Default::default(),
            }
        }
    }

    ///`NotificationResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "channel": {
    ///      "examples": [
    ///        "push"
    ///      ]
    ///    },
    ///    "content": {
    ///      "examples": [
    ///        "The content related to the notification."
    ///      ]
    ///    },
    ///    "deep_link_guid": {
    ///      "examples": [
    ///        "BGT-e386a323-e452-47f2-b2fd-1ac3c18533de"
    ///      ]
    ///    },
    ///    "delivered_at": {},
    ///    "entity_guid": {
    ///      "examples": [
    ///        "BGT-e386a323-e452-47f2-b2fd-1ac3c18533de"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "TF-b53294f5-2356-4782-9f81-ae064c42b40a"
    ///      ]
    ///    },
    ///    "has_been_delivered": {
    ///      "examples": [
    ///        true
    ///      ]
    ///    },
    ///    "has_been_viewed": {
    ///      "examples": [
    ///        false
    ///      ]
    ///    },
    ///    "notification_type": {
    ///      "examples": [
    ///        2
    ///      ]
    ///    },
    ///    "subject": {
    ///      "examples": [
    ///        "You're projected to spend $1,920.07 more than you've budgeted
    /// for Fees & Charges. You've already spent $65.67 of $316.00."
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NotificationResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub channel: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub content: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deep_link_guid: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub delivered_at: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub entity_guid: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_delivered: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_viewed: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notification_type: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub subject: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&NotificationResponse> for NotificationResponse {
        fn from(value: &NotificationResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for NotificationResponse {
        fn default() -> Self {
            Self {
                channel: Default::default(),
                content: Default::default(),
                deep_link_guid: Default::default(),
                delivered_at: Default::default(),
                entity_guid: Default::default(),
                guid: Default::default(),
                has_been_delivered: Default::default(),
                has_been_viewed: Default::default(),
                notification_type: Default::default(),
                subject: Default::default(),
            }
        }
    }

    ///`NotificationResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "notification": {
    ///      "$ref": "#/components/schemas/NotificationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NotificationResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub notification: ::std::option::Option<NotificationResponse>,
    }

    impl ::std::convert::From<&NotificationResponseBody> for NotificationResponseBody {
        fn from(value: &NotificationResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for NotificationResponseBody {
        fn default() -> Self {
            Self {
                notification: Default::default(),
            }
        }
    }

    ///`NotificationsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "notifications": {
    ///      "items": {
    ///        "$ref": "#/components/schemas/NotificationResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NotificationsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub notifications: ::std::vec::Vec<NotificationResponse>,
    }

    impl ::std::convert::From<&NotificationsResponseBody> for NotificationsResponseBody {
        fn from(value: &NotificationsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for NotificationsResponseBody {
        fn default() -> Self {
            Self {
                notifications: Default::default(),
            }
        }
    }

    ///`OAuthWindowResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "MBR-df96fd60-7122-4464-b3c2-ff11d8c74f6f"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "oauth_window_uri": {
    ///      "examples": [
    ///        "https://mxbank.mx.com/oauth/authorize?client_id=b8OikQ4Ep3NuSUrQ13DdvFuwpNx-qqoAsJDVAQCyLkQ&redirect_uri=https%3A%2F%2Fint-app.moneydesktop.com%2Foauth%2Fredirect_from&response_type=code&scope=openid&state=d745bd4ee6f0f9c184757f574bcc2df2"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OAuthWindowResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub oauth_window_uri: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&OAuthWindowResponse> for OAuthWindowResponse {
        fn from(value: &OAuthWindowResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for OAuthWindowResponse {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                oauth_window_uri: Default::default(),
            }
        }
    }

    ///`OAuthWindowResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "member": {
    ///      "$ref": "#/components/schemas/OAuthWindowResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OAuthWindowResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member: ::std::option::Option<OAuthWindowResponse>,
    }

    impl ::std::convert::From<&OAuthWindowResponseBody> for OAuthWindowResponseBody {
        fn from(value: &OAuthWindowResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for OAuthWindowResponseBody {
        fn default() -> Self {
            Self {
                member: Default::default(),
            }
        }
    }

    ///`OptionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "CRD-ce76d2e3-86bd-ec4a-ec52-eb53b5194bf5"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "label": {
    ///      "examples": [
    ///        "IMAGE_1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "value": {
    ///      "examples": [
    ///        "image_data"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OptionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub label: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&OptionResponse> for OptionResponse {
        fn from(value: &OptionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for OptionResponse {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                label: Default::default(),
                value: Default::default(),
            }
        }
    }

    ///`PaginationResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "current_page": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "per_page": {
    ///      "examples": [
    ///        25
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "total_entries": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "total_pages": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaginationResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_page: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub per_page: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_entries: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub total_pages: ::std::option::Option<i64>,
    }

    impl ::std::convert::From<&PaginationResponse> for PaginationResponse {
        fn from(value: &PaginationResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaginationResponse {
        fn default() -> Self {
            Self {
                current_page: Default::default(),
                per_page: Default::default(),
                total_entries: Default::default(),
                total_pages: Default::default(),
            }
        }
    }

    ///`PaymentAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "account_name": {
    ///      "examples": [
    ///        "MX Bank Checking"
    ///      ]
    ///    },
    ///    "account_number": {
    ///      "examples": [
    ///        6366816006
    ///      ]
    ///    },
    ///    "account_type": {
    ///      "examples": [
    ///        "CHECKING"
    ///      ]
    ///    },
    ///    "available_balance": {
    ///      "examples": [
    ///        1000
    ///      ]
    ///    },
    ///    "balance": {
    ///      "examples": [
    ///        1000
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2022-03-17T20:38:58Z"
    ///      ]
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        242722023
    ///      ]
    ///    },
    ///    "transit_number": {},
    ///    "updated_at": {
    ///      "examples": [
    ///        "2022-11-29T08:02:07Z"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentAccount {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_name: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_type: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transit_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&PaymentAccount> for PaymentAccount {
        fn from(value: &PaymentAccount) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentAccount {
        fn default() -> Self {
            Self {
                account_name: Default::default(),
                account_number: Default::default(),
                account_type: Default::default(),
                available_balance: Default::default(),
                balance: Default::default(),
                created_at: Default::default(),
                routing_number: Default::default(),
                transit_number: Default::default(),
                updated_at: Default::default(),
            }
        }
    }

    ///`PaymentAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payment_account": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/MemberElements"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/PaymentAccount"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentAccountBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_account: ::std::option::Option<PaymentAccountBodyPaymentAccount>,
    }

    impl ::std::convert::From<&PaymentAccountBody> for PaymentAccountBody {
        fn from(value: &PaymentAccountBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentAccountBody {
        fn default() -> Self {
            Self {
                payment_account: Default::default(),
            }
        }
    }

    ///`PaymentAccountBodyPaymentAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MemberElements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PaymentAccount"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentAccountBodyPaymentAccount {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_name: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_type: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub available_balance: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transit_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentAccountBodyPaymentAccount> for PaymentAccountBodyPaymentAccount {
        fn from(value: &PaymentAccountBodyPaymentAccount) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentAccountBodyPaymentAccount {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_name: Default::default(),
                account_number: Default::default(),
                account_type: Default::default(),
                available_balance: Default::default(),
                balance: Default::default(),
                created_at: Default::default(),
                member_guid: Default::default(),
                routing_number: Default::default(),
                transit_number: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`PaymentProcessorAuthorizationCodeRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_guid",
    ///    "member_guid",
    ///    "user_guid"
    ///  ],
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-4d4c0068-33bc-4d06-bbd6-cd270fd0135c"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-46637bc5-942d-4229-9370-ddd858bf805e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-f12b1f5a-7cbe-467c-aa30-0a10d0b2f549"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentProcessorAuthorizationCodeRequest {
        pub account_guid: ::std::string::String,
        pub member_guid: ::std::string::String,
        pub user_guid: ::std::string::String,
    }

    impl ::std::convert::From<&PaymentProcessorAuthorizationCodeRequest>
        for PaymentProcessorAuthorizationCodeRequest
    {
        fn from(value: &PaymentProcessorAuthorizationCodeRequest) -> Self {
            value.clone()
        }
    }

    ///`PaymentProcessorAuthorizationCodeRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payment_processor_authorization_code": {
    ///      "$ref":
    /// "#/components/schemas/PaymentProcessorAuthorizationCodeRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentProcessorAuthorizationCodeRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_processor_authorization_code:
            ::std::option::Option<PaymentProcessorAuthorizationCodeRequest>,
    }

    impl ::std::convert::From<&PaymentProcessorAuthorizationCodeRequestBody>
        for PaymentProcessorAuthorizationCodeRequestBody
    {
        fn from(value: &PaymentProcessorAuthorizationCodeRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentProcessorAuthorizationCodeRequestBody {
        fn default() -> Self {
            Self {
                payment_processor_authorization_code: Default::default(),
            }
        }
    }

    ///`PaymentProcessorAuthorizationCodeResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "authorization_code": {
    ///      "examples": [
    ///        "9nN-9D8_4Z3WYazx7-zXfmqsD3jwgL_2W927Sb3otI"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentProcessorAuthorizationCodeResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_code: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PaymentProcessorAuthorizationCodeResponse>
        for PaymentProcessorAuthorizationCodeResponse
    {
        fn from(value: &PaymentProcessorAuthorizationCodeResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentProcessorAuthorizationCodeResponse {
        fn default() -> Self {
            Self {
                authorization_code: Default::default(),
            }
        }
    }

    ///`PaymentProcessorAuthorizationCodeResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "payment_processor_authorization_code": {
    ///      "$ref":
    /// "#/components/schemas/PaymentProcessorAuthorizationCodeResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PaymentProcessorAuthorizationCodeResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_processor_authorization_code:
            ::std::option::Option<PaymentProcessorAuthorizationCodeResponse>,
    }

    impl ::std::convert::From<&PaymentProcessorAuthorizationCodeResponseBody>
        for PaymentProcessorAuthorizationCodeResponseBody
    {
        fn from(value: &PaymentProcessorAuthorizationCodeResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PaymentProcessorAuthorizationCodeResponseBody {
        fn default() -> Self {
            Self {
                payment_processor_authorization_code: Default::default(),
            }
        }
    }

    ///`ProcessorAccountNumber`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "account_number": {
    ///      "examples": [
    ///        6366816006
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "ACN-68c0b681-78c2-4731-9b41-d6e8ae2846cf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "institution_number": {},
    ///    "loan_guarantor": {},
    ///    "loan_reference_number": {},
    ///    "passed_validation": {
    ///      "examples": [
    ///        true
    ///      ]
    ///    },
    ///    "routing_number": {
    ///      "examples": [
    ///        242564563
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "sequence_number": {},
    ///    "transit_number": {}
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProcessorAccountNumber {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_guarantor: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_reference_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub passed_validation: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sequence_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transit_number: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&ProcessorAccountNumber> for ProcessorAccountNumber {
        fn from(value: &ProcessorAccountNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProcessorAccountNumber {
        fn default() -> Self {
            Self {
                account_number: Default::default(),
                guid: Default::default(),
                institution_number: Default::default(),
                loan_guarantor: Default::default(),
                loan_reference_number: Default::default(),
                passed_validation: Default::default(),
                routing_number: Default::default(),
                sequence_number: Default::default(),
                transit_number: Default::default(),
            }
        }
    }

    ///`ProcessorAccountNumberBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_numbers": {
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/MemberElements"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/ProcessorAccountNumber"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProcessorAccountNumberBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub account_numbers: ::std::vec::Vec<ProcessorAccountNumberBodyAccountNumbersItem>,
    }

    impl ::std::convert::From<&ProcessorAccountNumberBody> for ProcessorAccountNumberBody {
        fn from(value: &ProcessorAccountNumberBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProcessorAccountNumberBody {
        fn default() -> Self {
            Self {
                account_numbers: Default::default(),
            }
        }
    }

    ///`ProcessorAccountNumberBodyAccountNumbersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MemberElements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProcessorAccountNumber"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProcessorAccountNumberBodyAccountNumbersItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_number: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub institution_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_guarantor: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub loan_reference_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub passed_validation: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub routing_number: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sequence_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transit_number: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ProcessorAccountNumberBodyAccountNumbersItem>
        for ProcessorAccountNumberBodyAccountNumbersItem
    {
        fn from(value: &ProcessorAccountNumberBodyAccountNumbersItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProcessorAccountNumberBodyAccountNumbersItem {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_number: Default::default(),
                guid: Default::default(),
                institution_number: Default::default(),
                loan_guarantor: Default::default(),
                loan_reference_number: Default::default(),
                member_guid: Default::default(),
                passed_validation: Default::default(),
                routing_number: Default::default(),
                sequence_number: Default::default(),
                transit_number: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`ProcessorOwner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "address": {
    ///      "examples": [
    ///        "3541 Adrian Street"
    ///      ]
    ///    },
    ///    "city": {
    ///      "examples": [
    ///        "North Kishaberg"
    ///      ]
    ///    },
    ///    "country": {},
    ///    "email": {
    ///      "examples": [
    ///        "janita.pollich823@beerpowlowski.ca"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "ACO-a06b74ec-6a58-4c0b-b437-8de5e03194ac"
    ///      ]
    ///    },
    ///    "owner_name": {
    ///      "examples": [
    ///        "Janita Pollich"
    ///      ]
    ///    },
    ///    "phone": {
    ///      "examples": [
    ///        "676-932-5861"
    ///      ]
    ///    },
    ///    "postal_code": {
    ///      "examples": [
    ///        "45054-7764"
    ///      ]
    ///    },
    ///    "state": {
    ///      "examples": [
    ///        "Maine"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProcessorOwner {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_name: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<::serde_json::Value>,
    }

    impl ::std::convert::From<&ProcessorOwner> for ProcessorOwner {
        fn from(value: &ProcessorOwner) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProcessorOwner {
        fn default() -> Self {
            Self {
                address: Default::default(),
                city: Default::default(),
                country: Default::default(),
                email: Default::default(),
                guid: Default::default(),
                owner_name: Default::default(),
                phone: Default::default(),
                postal_code: Default::default(),
                state: Default::default(),
            }
        }
    }

    ///`ProcessorOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_owners": {
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/MemberElements"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/ProcessorOwner"
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProcessorOwnerBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub account_owners: ::std::vec::Vec<ProcessorOwnerBodyAccountOwnersItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&ProcessorOwnerBody> for ProcessorOwnerBody {
        fn from(value: &ProcessorOwnerBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProcessorOwnerBody {
        fn default() -> Self {
            Self {
                account_owners: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`ProcessorOwnerBodyAccountOwnersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MemberElements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/ProcessorOwner"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProcessorOwnerBodyAccountOwnersItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_name: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub phone: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<::serde_json::Value>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ProcessorOwnerBodyAccountOwnersItem>
        for ProcessorOwnerBodyAccountOwnersItem
    {
        fn from(value: &ProcessorOwnerBodyAccountOwnersItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProcessorOwnerBodyAccountOwnersItem {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                address: Default::default(),
                city: Default::default(),
                country: Default::default(),
                email: Default::default(),
                guid: Default::default(),
                member_guid: Default::default(),
                owner_name: Default::default(),
                phone: Default::default(),
                postal_code: Default::default(),
                state: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`RepeatingTransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-0af29528-bb91-447f-b5de-85c1c42593e5"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        107.4
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Dominion Energy"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "RPT-a2264e1a-d2e6-41d9-88d2-2cfdf1143959"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "last_posted_date": {
    ///      "examples": [
    ///        "2024-12-09"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-78b14c5f-7297-4fb5-a966-65ac45f74d83"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-1b5d7e4d-fa29-95d1-fd0f-540b6f17d986"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "predicted_occurs_on": {
    ///      "examples": [
    ///        "2025-01-09"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recurrence_type": {
    ///      "examples": [
    ///        "EVERY_MONTH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "repeating_transaction_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "BILL",
    ///        "SUBSCRIPTION",
    ///        "INCOME",
    ///        "UNKNOWN"
    ///      ]
    ///    },
    ///    "transaction_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "DEBIT",
    ///        "CREDIT"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepeatingTransactionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_posted_date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub predicted_occurs_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurrence_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repeating_transaction_type:
            ::std::option::Option<RepeatingTransactionResponseRepeatingTransactionType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_type: ::std::option::Option<RepeatingTransactionResponseTransactionType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RepeatingTransactionResponse> for RepeatingTransactionResponse {
        fn from(value: &RepeatingTransactionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RepeatingTransactionResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                amount: Default::default(),
                description: Default::default(),
                guid: Default::default(),
                last_posted_date: Default::default(),
                member_guid: Default::default(),
                merchant_guid: Default::default(),
                predicted_occurs_on: Default::default(),
                recurrence_type: Default::default(),
                repeating_transaction_type: Default::default(),
                transaction_type: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`RepeatingTransactionResponseRepeatingTransactionType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "BILL",
    ///    "SUBSCRIPTION",
    ///    "INCOME",
    ///    "UNKNOWN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RepeatingTransactionResponseRepeatingTransactionType {
        #[serde(rename = "BILL")]
        Bill,
        #[serde(rename = "SUBSCRIPTION")]
        Subscription,
        #[serde(rename = "INCOME")]
        Income,
        #[serde(rename = "UNKNOWN")]
        Unknown,
    }

    impl ::std::convert::From<&Self> for RepeatingTransactionResponseRepeatingTransactionType {
        fn from(value: &RepeatingTransactionResponseRepeatingTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RepeatingTransactionResponseRepeatingTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bill => f.write_str("BILL"),
                Self::Subscription => f.write_str("SUBSCRIPTION"),
                Self::Income => f.write_str("INCOME"),
                Self::Unknown => f.write_str("UNKNOWN"),
            }
        }
    }

    impl ::std::str::FromStr for RepeatingTransactionResponseRepeatingTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "BILL" => Ok(Self::Bill),
                "SUBSCRIPTION" => Ok(Self::Subscription),
                "INCOME" => Ok(Self::Income),
                "UNKNOWN" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RepeatingTransactionResponseRepeatingTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for RepeatingTransactionResponseRepeatingTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for RepeatingTransactionResponseRepeatingTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RepeatingTransactionResponseTransactionType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "DEBIT",
    ///    "CREDIT"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RepeatingTransactionResponseTransactionType {
        #[serde(rename = "DEBIT")]
        Debit,
        #[serde(rename = "CREDIT")]
        Credit,
    }

    impl ::std::convert::From<&Self> for RepeatingTransactionResponseTransactionType {
        fn from(value: &RepeatingTransactionResponseTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RepeatingTransactionResponseTransactionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Debit => f.write_str("DEBIT"),
                Self::Credit => f.write_str("CREDIT"),
            }
        }
    }

    impl ::std::str::FromStr for RepeatingTransactionResponseTransactionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "DEBIT" => Ok(Self::Debit),
                "CREDIT" => Ok(Self::Credit),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RepeatingTransactionResponseTransactionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for RepeatingTransactionResponseTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for RepeatingTransactionResponseTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RepeatingTransactionsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "repeating_transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RepeatingTransactionResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepeatingTransactionsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub repeating_transactions: ::std::vec::Vec<RepeatingTransactionResponse>,
    }

    impl ::std::convert::From<&RepeatingTransactionsResponseBody>
        for RepeatingTransactionsResponseBody
    {
        fn from(value: &RepeatingTransactionsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RepeatingTransactionsResponseBody {
        fn default() -> Self {
            Self {
                repeating_transactions: Default::default(),
            }
        }
    }

    ///`RepositionRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "required": [
    ///    "guid",
    ///    "position"
    ///  ],
    ///  "properties": {
    ///    "guid": {
    ///      "description": "The unique identifier for the goal. Defined by
    /// MX.",
    ///      "examples": [
    ///        "GOL-97665947-235c-b213-ca25-8cf0174774f5"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "position": {
    ///      "description": "The priority of the goal in relation to multiple
    /// goals.",
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositionRequest {
        ///The unique identifier for the goal. Defined by MX.
        pub guid: ::std::string::String,
        ///The priority of the goal in relation to multiple goals.
        pub position: i64,
    }

    impl ::std::convert::From<&RepositionRequest> for RepositionRequest {
        fn from(value: &RepositionRequest) -> Self {
            value.clone()
        }
    }

    ///`RepositionRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "goals": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RepositionRequest"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositionRequestBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub goals: ::std::vec::Vec<RepositionRequest>,
    }

    impl ::std::convert::From<&RepositionRequestBody> for RepositionRequestBody {
        fn from(value: &RepositionRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RepositionRequestBody {
        fn default() -> Self {
            Self {
                goals: Default::default(),
            }
        }
    }

    ///`RepositionResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "goals": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GoalsResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RepositionResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub goals: ::std::vec::Vec<GoalsResponse>,
    }

    impl ::std::convert::From<&RepositionResponseBody> for RepositionResponseBody {
        fn from(value: &RepositionResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RepositionResponseBody {
        fn default() -> Self {
            Self {
                goals: Default::default(),
            }
        }
    }

    ///`RewardElements`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "balance": {
    ///      "examples": [
    ///        102
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "balance_type": {
    ///      "examples": [
    ///        "EXPIRING_BALANCE"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2020-01-28T21:09:01+0000"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "A description of the reward."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "expires_on": {
    ///      "examples": [
    ///        "2020-02-28"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "RWD-1234"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "unit_type": {
    ///      "examples": [
    ///        "POINTS"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2023-06-01T19:18:06Z"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RewardElements {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unit_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RewardElements> for RewardElements {
        fn from(value: &RewardElements) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RewardElements {
        fn default() -> Self {
            Self {
                balance: Default::default(),
                balance_type: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                expires_on: Default::default(),
                guid: Default::default(),
                unit_type: Default::default(),
                updated_at: Default::default(),
            }
        }
    }

    ///`RewardResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "reward": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/MemberElements"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/RewardElements"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RewardResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reward: ::std::option::Option<RewardResponseBodyReward>,
    }

    impl ::std::convert::From<&RewardResponseBody> for RewardResponseBody {
        fn from(value: &RewardResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RewardResponseBody {
        fn default() -> Self {
            Self {
                reward: Default::default(),
            }
        }
    }

    ///`RewardResponseBodyReward`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MemberElements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/RewardElements"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RewardResponseBodyReward {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unit_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RewardResponseBodyReward> for RewardResponseBodyReward {
        fn from(value: &RewardResponseBodyReward) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RewardResponseBodyReward {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                balance: Default::default(),
                balance_type: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                expires_on: Default::default(),
                guid: Default::default(),
                member_guid: Default::default(),
                unit_type: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`RewardsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "rewards": {
    ///      "type": "array",
    ///      "items": {
    ///        "allOf": [
    ///          {
    ///            "$ref": "#/components/schemas/MemberElements"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/RewardElements"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RewardsResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub rewards: ::std::vec::Vec<RewardsResponseBodyRewardsItem>,
    }

    impl ::std::convert::From<&RewardsResponseBody> for RewardsResponseBody {
        fn from(value: &RewardsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RewardsResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                rewards: Default::default(),
            }
        }
    }

    ///`RewardsResponseBodyRewardsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/MemberElements"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/RewardElements"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RewardsResponseBodyRewardsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub balance_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub unit_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RewardsResponseBodyRewardsItem> for RewardsResponseBodyRewardsItem {
        fn from(value: &RewardsResponseBodyRewardsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RewardsResponseBodyRewardsItem {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                balance: Default::default(),
                balance_type: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                expires_on: Default::default(),
                guid: Default::default(),
                member_guid: Default::default(),
                unit_type: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`ScheduledPaymentResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        13.54
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2023-04-27T23:14:16Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Netflix"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "SPA-c76e4a85-b2c4-4335-82b7-8f8b8f28c35a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_completed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_recurring": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-b8a2624c-2176-59ec-c150-37854bc38aa8"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "occurs_on": {
    ///      "examples": [
    ///        "2022-01-15"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recurrence_day": {
    ///      "examples": [
    ///        15
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "recurrence_type": {
    ///      "examples": [
    ///        "EVERY_MONTH"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transaction_type": {
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2023-04-27T23:14:16Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-72086f59-6684-4adf-8f29-c4d32db43cd7"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScheduledPaymentResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_completed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_recurring: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub occurs_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurrence_day: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurrence_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ScheduledPaymentResponse> for ScheduledPaymentResponse {
        fn from(value: &ScheduledPaymentResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ScheduledPaymentResponse {
        fn default() -> Self {
            Self {
                amount: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                guid: Default::default(),
                is_completed: Default::default(),
                is_recurring: Default::default(),
                merchant_guid: Default::default(),
                occurs_on: Default::default(),
                recurrence_day: Default::default(),
                recurrence_type: Default::default(),
                transaction_type: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`ScheduledPaymentsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "scheduled_payments": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ScheduledPaymentResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScheduledPaymentsResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub scheduled_payments: ::std::vec::Vec<ScheduledPaymentResponse>,
    }

    impl ::std::convert::From<&ScheduledPaymentsResponseBody> for ScheduledPaymentsResponseBody {
        fn from(value: &ScheduledPaymentsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ScheduledPaymentsResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                scheduled_payments: Default::default(),
            }
        }
    }

    ///`SpendingPlanAccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-97d3948f-ebe7-434a-9bd0-20b29d67c9d4"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "client_guid": {
    ///      "examples": [
    ///        "CLT-024284fc-a6a7-42ee-b363-dab9343e3f72"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2023-04-27T23:14:16Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "SPA-c76e4a85-b2c4-4335-82b7-8f8b8f28c35a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "spending_plan_guid": {
    ///      "examples": [
    ///        "SPL-dbfe201d-c341-4bff-93c0-62a918d0b600"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2023-04-27T23:14:16Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-72086f59-6684-4adf-8f29-c4d32db43cd7"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanAccountResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub spending_plan_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SpendingPlanAccountResponse> for SpendingPlanAccountResponse {
        fn from(value: &SpendingPlanAccountResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanAccountResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                client_guid: Default::default(),
                created_at: Default::default(),
                guid: Default::default(),
                spending_plan_guid: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`SpendingPlanAccountsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "spending_plan_accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SpendingPlanAccountResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanAccountsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub spending_plan_accounts: ::std::vec::Vec<SpendingPlanAccountResponse>,
    }

    impl ::std::convert::From<&SpendingPlanAccountsResponse> for SpendingPlanAccountsResponse {
        fn from(value: &SpendingPlanAccountsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanAccountsResponse {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                spending_plan_accounts: Default::default(),
            }
        }
    }

    ///`SpendingPlanIterationItemCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "planned_amount"
    ///  ],
    ///  "properties": {
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-40faf068-abb4-405c-8f6a-e883ed541fff"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "item_type": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "planned_amount": {
    ///      "examples": [
    ///        110
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "scheduled_payment_guid": {
    ///      "examples": [
    ///        "SCP-c731988a-712f-4f83-9b3b-0aa5b3d5208b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "top_level_category_guid": {
    ///      "examples": [
    ///        "CAT-9588eaad-90a4-bb5c-66c8-1812503d0db8"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanIterationItemCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub item_type: ::std::option::Option<f64>,
        pub planned_amount: f64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scheduled_payment_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub top_level_category_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SpendingPlanIterationItemCreateRequestBody>
        for SpendingPlanIterationItemCreateRequestBody
    {
        fn from(value: &SpendingPlanIterationItemCreateRequestBody) -> Self {
            value.clone()
        }
    }

    ///`SpendingPlanIterationItemResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "actual_amount": {
    ///      "examples": [
    ///        345
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-40faf068-abb4-405c-8f6a-e883ed541fff"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2016-10-13T18:08:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "SPL-e5f9a5bd-c5b3-4901-bdc0-62119b9db262"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "item_type": {
    ///      "examples": [
    ///        "1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "planned_amount": {
    ///      "examples": [
    ///        110
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "scheduled_payment_guid": {
    ///      "examples": [
    ///        "SCP-c731988a-712f-4f83-9b3b-0aa5b3d5208b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "spending_plan_iteration_guid": {
    ///      "examples": [
    ///        "SPI-848e6648-3fa3-4632-ac8f-e65f03167102"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "top_level_category_guid": {
    ///      "examples": [
    ///        "CAT-9588eaad-90a4-bb5c-66c8-1812503d0db8"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transaction_guids": {
    ///      "type": "array",
    ///      "items": {
    ///        "examples": [
    ///          "TRN-265abee9-889b-af6a-c69b-25157db2bdd9"
    ///        ],
    ///        "type": [
    ///          "string",
    ///          "null"
    ///        ]
    ///      }
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:09:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanIterationItemResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub actual_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub item_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub planned_amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scheduled_payment_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub spending_plan_iteration_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub top_level_category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transaction_guids: ::std::vec::Vec<::std::option::Option<::std::string::String>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SpendingPlanIterationItemResponse>
        for SpendingPlanIterationItemResponse
    {
        fn from(value: &SpendingPlanIterationItemResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanIterationItemResponse {
        fn default() -> Self {
            Self {
                actual_amount: Default::default(),
                category_guid: Default::default(),
                created_at: Default::default(),
                guid: Default::default(),
                item_type: Default::default(),
                planned_amount: Default::default(),
                scheduled_payment_guid: Default::default(),
                spending_plan_iteration_guid: Default::default(),
                top_level_category_guid: Default::default(),
                transaction_guids: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`SpendingPlanIterationItemsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "iteration_items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SpendingPlanIterationItemResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanIterationItemsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub iteration_items: ::std::vec::Vec<SpendingPlanIterationItemResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&SpendingPlanIterationItemsResponseBody>
        for SpendingPlanIterationItemsResponseBody
    {
        fn from(value: &SpendingPlanIterationItemsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanIterationItemsResponseBody {
        fn default() -> Self {
            Self {
                iteration_items: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`SpendingPlanIterationResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "created_at": {
    ///      "examples": [
    ///        "2016-10-13T18:08:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "end_on": {
    ///      "examples": [
    ///        "2023-05-31"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "SPI-848e6648-3fa3-4632-ac8f-e65f03167102"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "iteration_number": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "spending_plan_guid": {
    ///      "examples": [
    ///        "SPL-dbfe201d-c341-4bff-93c0-62a918d0b600"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "start_on": {
    ///      "examples": [
    ///        "2023-05-01"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:09:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-72086f59-6684-4adf-8f29-c4d32db43cd7"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanIterationResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub end_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iteration_number: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub spending_plan_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub start_on: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SpendingPlanIterationResponse> for SpendingPlanIterationResponse {
        fn from(value: &SpendingPlanIterationResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanIterationResponse {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                end_on: Default::default(),
                guid: Default::default(),
                iteration_number: Default::default(),
                spending_plan_guid: Default::default(),
                start_on: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`SpendingPlanIterationsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "iterations": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SpendingPlanIterationResponse"
    ///      }
    ///    },
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanIterationsResponse {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub iterations: ::std::vec::Vec<SpendingPlanIterationResponse>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
    }

    impl ::std::convert::From<&SpendingPlanIterationsResponse> for SpendingPlanIterationsResponse {
        fn from(value: &SpendingPlanIterationsResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanIterationsResponse {
        fn default() -> Self {
            Self {
                iterations: Default::default(),
                pagination: Default::default(),
            }
        }
    }

    ///`SpendingPlanResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "created_at": {
    ///      "examples": [
    ///        "2016-10-13T18:08:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "current_iteration_number": {
    ///      "examples": [
    ///        1
    ///      ],
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "SPL-e5f9a5bd-c5b3-4901-bdc0-62119b9db262"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:09:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlanResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_iteration_number: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SpendingPlanResponse> for SpendingPlanResponse {
        fn from(value: &SpendingPlanResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlanResponse {
        fn default() -> Self {
            Self {
                created_at: Default::default(),
                current_iteration_number: Default::default(),
                guid: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`SpendingPlansResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "spending_plans": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SpendingPlanResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpendingPlansResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub spending_plans: ::std::vec::Vec<SpendingPlanResponse>,
    }

    impl ::std::convert::From<&SpendingPlansResponseBody> for SpendingPlansResponseBody {
        fn from(value: &SpendingPlansResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SpendingPlansResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                spending_plans: Default::default(),
            }
        }
    }

    ///`SplitTransactionRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "required": [
    ///    "amount"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "description": "Amount of money you want to re-categorize.",
    ///      "examples": [
    ///        54.19
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "category_guid": {
    ///      "description": "Unique identifier of the category.",
    ///      "examples": [
    ///        "CAT-b6d61a19-30a7-e852-2703-bdfb4072289e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "Description for the split transaction.",
    ///      "examples": [
    ///        "Chevron Gas"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "memo": {
    ///      "description": "Memo for the split transaction",
    ///      "examples": [
    ///        "Chips and Soda"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SplitTransactionRequest {
        pub amount: f64,
        ///Unique identifier of the category.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        ///Description for the split transaction.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        ///Memo for the split transaction
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SplitTransactionRequest> for SplitTransactionRequest {
        fn from(value: &SplitTransactionRequest) -> Self {
            value.clone()
        }
    }

    ///`SplitTransactionRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transactions"
    ///  ],
    ///  "properties": {
    ///    "transactions": {
    ///      "$ref": "#/components/schemas/SplitTransactionRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SplitTransactionRequestBody {
        pub transactions: SplitTransactionRequest,
    }

    impl ::std::convert::From<&SplitTransactionRequestBody> for SplitTransactionRequestBody {
        fn from(value: &SplitTransactionRequestBody) -> Self {
            value.clone()
        }
    }

    ///`SplitTransactionsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SplitTransactionsResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transactions: ::std::vec::Vec<TransactionResponse>,
    }

    impl ::std::convert::From<&SplitTransactionsResponseBody> for SplitTransactionsResponseBody {
        fn from(value: &SplitTransactionsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SplitTransactionsResponseBody {
        fn default() -> Self {
            Self {
                transactions: Default::default(),
            }
        }
    }

    ///`StatementResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "content_hash": {
    ///      "examples": [
    ///        "ca53785b812d00ef821c3d94bfd6e5bbc0020504410589b7ea8552169f021981"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2016-10-13T18:08:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "STA-737a344b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2016-10-13T18:09:00+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "uri": {
    ///      "examples": [
    ///        "uri/to/statement"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StatementResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub content_hash: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub uri: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&StatementResponse> for StatementResponse {
        fn from(value: &StatementResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for StatementResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                content_hash: Default::default(),
                created_at: Default::default(),
                guid: Default::default(),
                member_guid: Default::default(),
                updated_at: Default::default(),
                uri: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`StatementResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "statement": {
    ///      "$ref": "#/components/schemas/StatementResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StatementResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub statement: ::std::option::Option<StatementResponse>,
    }

    impl ::std::convert::From<&StatementResponseBody> for StatementResponseBody {
        fn from(value: &StatementResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for StatementResponseBody {
        fn default() -> Self {
            Self {
                statement: Default::default(),
            }
        }
    }

    ///`StatementsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "statements": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/StatementResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct StatementsResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub statements: ::std::vec::Vec<StatementResponse>,
    }

    impl ::std::convert::From<&StatementsResponseBody> for StatementsResponseBody {
        fn from(value: &StatementsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for StatementsResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                statements: Default::default(),
            }
        }
    }

    ///`TagCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "examples": [
    ///        "MY TAG"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagCreateRequest {
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&TagCreateRequest> for TagCreateRequest {
        fn from(value: &TagCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`TagCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tag": {
    ///      "$ref": "#/components/schemas/TagCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tag: ::std::option::Option<TagCreateRequest>,
    }

    impl ::std::convert::From<&TagCreateRequestBody> for TagCreateRequestBody {
        fn from(value: &TagCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TagCreateRequestBody {
        fn default() -> Self {
            Self {
                tag: Default::default(),
            }
        }
    }

    ///`TagResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "TAG-aef36e72-6294-4c38-844d-e573e80aed52"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "MY TAG"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-11141024-90b3-1bce-cac9-c06ced52ab4c"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TagResponse> for TagResponse {
        fn from(value: &TagResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TagResponse {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                name: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`TagResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tag": {
    ///      "$ref": "#/components/schemas/TagResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tag: ::std::option::Option<TagResponse>,
    }

    impl ::std::convert::From<&TagResponseBody> for TagResponseBody {
        fn from(value: &TagResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TagResponseBody {
        fn default() -> Self {
            Self {
                tag: Default::default(),
            }
        }
    }

    ///`TagUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "examples": [
    ///        "MY TAG"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagUpdateRequest {
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&TagUpdateRequest> for TagUpdateRequest {
        fn from(value: &TagUpdateRequest) -> Self {
            value.clone()
        }
    }

    ///`TagUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tag": {
    ///      "$ref": "#/components/schemas/TagUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tag: ::std::option::Option<TagUpdateRequest>,
    }

    impl ::std::convert::From<&TagUpdateRequestBody> for TagUpdateRequestBody {
        fn from(value: &TagUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TagUpdateRequestBody {
        fn default() -> Self {
            Self {
                tag: Default::default(),
            }
        }
    }

    ///`TaggingCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tag_guid",
    ///    "transaction_guid"
    ///  ],
    ///  "properties": {
    ///    "tag_guid": {
    ///      "examples": [
    ///        "TAG-40faf068-abb4-405c-8f6a-e883ed541fff"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "transaction_guid": {
    ///      "examples": [
    ///        "TRN-810828b0-5210-4878-9bd3-f4ce514f90c4"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingCreateRequest {
        pub tag_guid: ::std::string::String,
        pub transaction_guid: ::std::string::String,
    }

    impl ::std::convert::From<&TaggingCreateRequest> for TaggingCreateRequest {
        fn from(value: &TaggingCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`TaggingCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tagging": {
    ///      "$ref": "#/components/schemas/TaggingCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tagging: ::std::option::Option<TaggingCreateRequest>,
    }

    impl ::std::convert::From<&TaggingCreateRequestBody> for TaggingCreateRequestBody {
        fn from(value: &TaggingCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TaggingCreateRequestBody {
        fn default() -> Self {
            Self {
                tagging: Default::default(),
            }
        }
    }

    ///`TaggingResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "TGN-007f5486-17e1-45fc-8b87-8f03984430fe"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_is_managed_by_user": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "tag_guid": {
    ///      "examples": [
    ///        "TAG-40faf068-abb4-405c-8f6a-e883ed541fff"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transaction_guid": {
    ///      "examples": [
    ///        "TRN-810828b0-5210-4878-9bd3-f4ce514f90c4"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-11141024-90b3-1bce-cac9-c06ced52ab4c"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_is_managed_by_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tag_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TaggingResponse> for TaggingResponse {
        fn from(value: &TaggingResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TaggingResponse {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                member_is_managed_by_user: Default::default(),
                tag_guid: Default::default(),
                transaction_guid: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`TaggingResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tagging": {
    ///      "$ref": "#/components/schemas/TaggingResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tagging: ::std::option::Option<TaggingResponse>,
    }

    impl ::std::convert::From<&TaggingResponseBody> for TaggingResponseBody {
        fn from(value: &TaggingResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TaggingResponseBody {
        fn default() -> Self {
            Self {
                tagging: Default::default(),
            }
        }
    }

    ///`TaggingUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tag_guid"
    ///  ],
    ///  "properties": {
    ///    "tag_guid": {
    ///      "examples": [
    ///        "TAG-40faf068-abb4-405c-8f6a-e883ed541fff"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingUpdateRequest {
        pub tag_guid: ::std::string::String,
    }

    impl ::std::convert::From<&TaggingUpdateRequest> for TaggingUpdateRequest {
        fn from(value: &TaggingUpdateRequest) -> Self {
            value.clone()
        }
    }

    ///`TaggingUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tagging": {
    ///      "$ref": "#/components/schemas/TaggingUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tagging: ::std::option::Option<TaggingUpdateRequest>,
    }

    impl ::std::convert::From<&TaggingUpdateRequestBody> for TaggingUpdateRequestBody {
        fn from(value: &TaggingUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TaggingUpdateRequestBody {
        fn default() -> Self {
            Self {
                tagging: Default::default(),
            }
        }
    }

    ///`TaggingsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "taggings": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TaggingResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaggingsResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub taggings: ::std::vec::Vec<TaggingResponse>,
    }

    impl ::std::convert::From<&TaggingsResponseBody> for TaggingsResponseBody {
        fn from(value: &TaggingsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TaggingsResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                taggings: Default::default(),
            }
        }
    }

    ///`TagsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "tags": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TagResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TagsResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub tags: ::std::vec::Vec<TagResponse>,
    }

    impl ::std::convert::From<&TagsResponseBody> for TagsResponseBody {
        fn from(value: &TagsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TagsResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                tags: Default::default(),
            }
        }
    }

    ///`TokenRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "scope": {
    ///      "$ref": "#/components/schemas/MemberElements"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TokenRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub scope: ::std::option::Option<MemberElements>,
    }

    impl ::std::convert::From<&TokenRequestBody> for TokenRequestBody {
        fn from(value: &TokenRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TokenRequestBody {
        fn default() -> Self {
            Self {
                scope: Default::default(),
            }
        }
    }

    ///`TokenResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "access_token": {
    ///      "examples": [
    ///        "i8FnF..."
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "active": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "expires_at": {
    ///      "examples": [
    ///        "2023-04-19T15:38:2800:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "payment_processor_guid": {
    ///      "examples": [
    ///        "PPR-084aa709-8218-4b5a-b3ab-70ffc7483daf"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TokenResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub access_token: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub active: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expires_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub payment_processor_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TokenResponse> for TokenResponse {
        fn from(value: &TokenResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TokenResponse {
        fn default() -> Self {
            Self {
                access_token: Default::default(),
                active: Default::default(),
                expires_at: Default::default(),
                payment_processor_guid: Default::default(),
            }
        }
    }

    ///`TokenResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "tokens": {
    ///      "items": {
    ///        "$ref": "#/components/schemas/TokenResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TokenResponseBody {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub tokens: ::std::vec::Vec<TokenResponse>,
    }

    impl ::std::convert::From<&TokenResponseBody> for TokenResponseBody {
        fn from(value: &TokenResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TokenResponseBody {
        fn default() -> Self {
            Self {
                tokens: Default::default(),
            }
        }
    }

    ///`TransactionCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "required": [
    ///    "amount",
    ///    "date",
    ///    "description",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "examples": [
    ///        61.11
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "category_guid": {
    ///      "description": "Unique identifier of the category.",
    ///      "examples": [
    ///        "CAT-b6d61a19-30a7-e852-2703-bdfb4072289e"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "date": {
    ///      "examples": [
    ///        "2016-10-06"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Whole foods"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "has_been_viewed": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_hidden": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_international": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "This is a memo"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "skip_webhook": {
    ///      "description": "When set to true, this parameter will prevent a
    /// webhook from being triggered by the request.",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "type": {
    ///      "description": "The type of transaction, which must be CREDIT or
    /// DEBIT. See Transaction Fields for more information.",
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionCreateRequest {
        pub amount: f64,
        ///Unique identifier of the category.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        pub date: ::std::string::String,
        pub description: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_viewed: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_hidden: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///When set to true, this parameter will prevent a webhook from being
        /// triggered by the request.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub skip_webhook: ::std::option::Option<bool>,
        ///The type of transaction, which must be CREDIT or DEBIT. See
        /// Transaction Fields for more information.
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&TransactionCreateRequest> for TransactionCreateRequest {
        fn from(value: &TransactionCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`TransactionCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction": {
    ///      "$ref": "#/components/schemas/TransactionCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction: ::std::option::Option<TransactionCreateRequest>,
    }

    impl ::std::convert::From<&TransactionCreateRequestBody> for TransactionCreateRequestBody {
        fn from(value: &TransactionCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionCreateRequestBody {
        fn default() -> Self {
            Self {
                transaction: Default::default(),
            }
        }
    }

    ///`TransactionCreateResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-06d7f44b-caae-0f6e-1384-01f52e75dcb1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "account_id": {
    ///      "examples": [
    ///        "account123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        61.11
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "category": {
    ///      "examples": [
    ///        "Groceries"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-b6d61a19-30a7-e852-2703-bdfb4072289e"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "check_number_string": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2016-10-08T09:43:42.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "currency_code": {
    ///      "examples": [
    ///        "USD"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "date": {
    ///      "examples": [
    ///        "2016-10-06T00:00:00.000Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Whole foods"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "extended_transaction_type": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "TRN-265abee9-889b-af6a-c69b-25157db2bdd9"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_bill_pay": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_direct_deposit": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_expense": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_fee": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_income": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_international": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_manual": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_overdraft_fee": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_payroll_advance": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_recurring": {
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_subscription": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "latitude": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "localized_description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "localized_memo": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "longitude": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_is_managed_by_user": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "This is a memo"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_category_code": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_guid": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_location_guid": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "some metadata"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "original_description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "posted_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "status": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "top_level_category": {
    ///      "examples": [
    ///        "Food & Dining"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transacted_at": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "DEBIT"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2016-10-08T05:49:12.000Z"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-fa7537f3-48aa-a683-a02a-b18940482f54"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "examples": [
    ///        "user123"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionCreateResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub check_number_string: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extended_transaction_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_bill_pay: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_direct_deposit: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_expense: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_income: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_manual: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_overdraft_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_payroll_advance: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_recurring: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_subscription: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub longitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_is_managed_by_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub posted_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub top_level_category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transacted_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionCreateResponseBody> for TransactionCreateResponseBody {
        fn from(value: &TransactionCreateResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionCreateResponseBody {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_id: Default::default(),
                amount: Default::default(),
                category: Default::default(),
                category_guid: Default::default(),
                check_number_string: Default::default(),
                created_at: Default::default(),
                currency_code: Default::default(),
                date: Default::default(),
                description: Default::default(),
                extended_transaction_type: Default::default(),
                guid: Default::default(),
                id: Default::default(),
                is_bill_pay: Default::default(),
                is_direct_deposit: Default::default(),
                is_expense: Default::default(),
                is_fee: Default::default(),
                is_income: Default::default(),
                is_international: Default::default(),
                is_manual: Default::default(),
                is_overdraft_fee: Default::default(),
                is_payroll_advance: Default::default(),
                is_recurring: Default::default(),
                is_subscription: Default::default(),
                latitude: Default::default(),
                localized_description: Default::default(),
                localized_memo: Default::default(),
                longitude: Default::default(),
                member_guid: Default::default(),
                member_is_managed_by_user: Default::default(),
                memo: Default::default(),
                merchant_category_code: Default::default(),
                merchant_guid: Default::default(),
                merchant_location_guid: Default::default(),
                metadata: Default::default(),
                original_description: Default::default(),
                posted_at: Default::default(),
                status: Default::default(),
                top_level_category: Default::default(),
                transacted_at: Default::default(),
                type_: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`TransactionIncludesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/TransactionResponse"
    ///    },
    ///    {
    ///      "properties": {
    ///        "classification": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "guid": {
    ///              "examples": [
    ///                "MNC-3ad50f86-60d0-4545-a1f9-e66c2ac40f69"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "parent_class": {
    ///              "examples": [
    ///                "Deposit"
    ///              ],
    ///              "type": "string",
    ///              "enum": [
    ///                "Payroll",
    ///                "Deposit",
    ///                "Savings",
    ///                "Transfer",
    ///                "Refunds",
    ///                "Spend",
    ///                "Investment",
    ///                "Buy",
    ///                "Sell",
    ///                "Income",
    ///                "Fees",
    ///                "Expenses",
    ///                "Corporate Actions",
    ///                "Other"
    ///              ]
    ///            }
    ///          }
    ///        },
    ///        "geolocation": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "city": {
    ///              "examples": [
    ///                "lehi"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "country": {
    ///              "examples": [
    ///                "us"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "postal code": {
    ///              "examples": [
    ///                "84043"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "state": {
    ///              "examples": [
    ///                "UT"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "merchant": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "guid": {
    ///              "examples": [
    ///                "MCH-0c25f895-393c-42a4-9c18-95a0b26d4d84"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "logo_url": {
    ///              "examples": [
    ///                "https://content.mx.com/logos/merchants/MCH-0c25f895-393c-42a4-9c18-95a0b26d4d84.png"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "name": {
    ///              "examples": [
    ///                "MX"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "website_url": {
    ///              "examples": [
    ///                "https://www.mx.com"
    ///              ],
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "repeating_transaction": {
    ///          "type": [
    ///            "object",
    ///            "null"
    ///          ],
    ///          "properties": {
    ///            "guid": {
    ///              "examples": [
    ///                "RPT-065b8b1d-826a-45ce-8487-60ca1510e72a"
    ///              ],
    ///              "type": "string"
    ///            },
    ///            "recurrence_type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "EVERY_OTHER_WEEK"
    ///              ]
    ///            },
    ///            "repeating_transaction_type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "BILL",
    ///                "SUBSCRIPTION",
    ///                "INCOME",
    ///                "UNKNOWN"
    ///              ]
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionIncludesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub check_number_string: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub classification: ::std::option::Option<TransactionIncludesResponseClassification>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extended_transaction_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub geolocation: ::std::option::Option<TransactionIncludesResponseGeolocation>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_bill_pay: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_direct_deposit: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_expense: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_income: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_manual: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_overdraft_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_payroll_advance: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_recurring: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_subscription: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub longitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_is_managed_by_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant: ::std::option::Option<TransactionIncludesResponseMerchant>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub posted_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repeating_transaction:
            ::std::option::Option<TransactionIncludesResponseRepeatingTransaction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub top_level_category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transacted_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionIncludesResponse> for TransactionIncludesResponse {
        fn from(value: &TransactionIncludesResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionIncludesResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_id: Default::default(),
                amount: Default::default(),
                category: Default::default(),
                category_guid: Default::default(),
                check_number_string: Default::default(),
                classification: Default::default(),
                created_at: Default::default(),
                currency_code: Default::default(),
                date: Default::default(),
                description: Default::default(),
                extended_transaction_type: Default::default(),
                geolocation: Default::default(),
                guid: Default::default(),
                id: Default::default(),
                is_bill_pay: Default::default(),
                is_direct_deposit: Default::default(),
                is_expense: Default::default(),
                is_fee: Default::default(),
                is_income: Default::default(),
                is_international: Default::default(),
                is_manual: Default::default(),
                is_overdraft_fee: Default::default(),
                is_payroll_advance: Default::default(),
                is_recurring: Default::default(),
                is_subscription: Default::default(),
                latitude: Default::default(),
                localized_description: Default::default(),
                localized_memo: Default::default(),
                longitude: Default::default(),
                member_guid: Default::default(),
                member_is_managed_by_user: Default::default(),
                memo: Default::default(),
                merchant: Default::default(),
                merchant_category_code: Default::default(),
                merchant_guid: Default::default(),
                merchant_location_guid: Default::default(),
                metadata: Default::default(),
                original_description: Default::default(),
                posted_at: Default::default(),
                repeating_transaction: Default::default(),
                status: Default::default(),
                top_level_category: Default::default(),
                transacted_at: Default::default(),
                type_: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`TransactionIncludesResponseClassification`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "MNC-3ad50f86-60d0-4545-a1f9-e66c2ac40f69"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "parent_class": {
    ///      "examples": [
    ///        "Deposit"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "Payroll",
    ///        "Deposit",
    ///        "Savings",
    ///        "Transfer",
    ///        "Refunds",
    ///        "Spend",
    ///        "Investment",
    ///        "Buy",
    ///        "Sell",
    ///        "Income",
    ///        "Fees",
    ///        "Expenses",
    ///        "Corporate Actions",
    ///        "Other"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionIncludesResponseClassification {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub parent_class:
            ::std::option::Option<TransactionIncludesResponseClassificationParentClass>,
    }

    impl ::std::convert::From<&TransactionIncludesResponseClassification>
        for TransactionIncludesResponseClassification
    {
        fn from(value: &TransactionIncludesResponseClassification) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionIncludesResponseClassification {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                parent_class: Default::default(),
            }
        }
    }

    ///`TransactionIncludesResponseClassificationParentClass`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    "Deposit"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "Payroll",
    ///    "Deposit",
    ///    "Savings",
    ///    "Transfer",
    ///    "Refunds",
    ///    "Spend",
    ///    "Investment",
    ///    "Buy",
    ///    "Sell",
    ///    "Income",
    ///    "Fees",
    ///    "Expenses",
    ///    "Corporate Actions",
    ///    "Other"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransactionIncludesResponseClassificationParentClass {
        Payroll,
        Deposit,
        Savings,
        Transfer,
        Refunds,
        Spend,
        Investment,
        Buy,
        Sell,
        Income,
        Fees,
        Expenses,
        #[serde(rename = "Corporate Actions")]
        CorporateActions,
        Other,
    }

    impl ::std::convert::From<&Self> for TransactionIncludesResponseClassificationParentClass {
        fn from(value: &TransactionIncludesResponseClassificationParentClass) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TransactionIncludesResponseClassificationParentClass {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Payroll => f.write_str("Payroll"),
                Self::Deposit => f.write_str("Deposit"),
                Self::Savings => f.write_str("Savings"),
                Self::Transfer => f.write_str("Transfer"),
                Self::Refunds => f.write_str("Refunds"),
                Self::Spend => f.write_str("Spend"),
                Self::Investment => f.write_str("Investment"),
                Self::Buy => f.write_str("Buy"),
                Self::Sell => f.write_str("Sell"),
                Self::Income => f.write_str("Income"),
                Self::Fees => f.write_str("Fees"),
                Self::Expenses => f.write_str("Expenses"),
                Self::CorporateActions => f.write_str("Corporate Actions"),
                Self::Other => f.write_str("Other"),
            }
        }
    }

    impl ::std::str::FromStr for TransactionIncludesResponseClassificationParentClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "Payroll" => Ok(Self::Payroll),
                "Deposit" => Ok(Self::Deposit),
                "Savings" => Ok(Self::Savings),
                "Transfer" => Ok(Self::Transfer),
                "Refunds" => Ok(Self::Refunds),
                "Spend" => Ok(Self::Spend),
                "Investment" => Ok(Self::Investment),
                "Buy" => Ok(Self::Buy),
                "Sell" => Ok(Self::Sell),
                "Income" => Ok(Self::Income),
                "Fees" => Ok(Self::Fees),
                "Expenses" => Ok(Self::Expenses),
                "Corporate Actions" => Ok(Self::CorporateActions),
                "Other" => Ok(Self::Other),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TransactionIncludesResponseClassificationParentClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for TransactionIncludesResponseClassificationParentClass
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for TransactionIncludesResponseClassificationParentClass
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TransactionIncludesResponseGeolocation`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "city": {
    ///      "examples": [
    ///        "lehi"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "examples": [
    ///        "us"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "postal code": {
    ///      "examples": [
    ///        "84043"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "state": {
    ///      "examples": [
    ///        "UT"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionIncludesResponseGeolocation {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub city: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub country: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "postal code",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub postal_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionIncludesResponseGeolocation>
        for TransactionIncludesResponseGeolocation
    {
        fn from(value: &TransactionIncludesResponseGeolocation) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionIncludesResponseGeolocation {
        fn default() -> Self {
            Self {
                city: Default::default(),
                country: Default::default(),
                postal_code: Default::default(),
                state: Default::default(),
            }
        }
    }

    ///`TransactionIncludesResponseMerchant`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "MCH-0c25f895-393c-42a4-9c18-95a0b26d4d84"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "logo_url": {
    ///      "examples": [
    ///        "https://content.mx.com/logos/merchants/MCH-0c25f895-393c-42a4-9c18-95a0b26d4d84.png"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "examples": [
    ///        "MX"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "website_url": {
    ///      "examples": [
    ///        "https://www.mx.com"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionIncludesResponseMerchant {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub logo_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub website_url: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionIncludesResponseMerchant>
        for TransactionIncludesResponseMerchant
    {
        fn from(value: &TransactionIncludesResponseMerchant) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionIncludesResponseMerchant {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                logo_url: Default::default(),
                name: Default::default(),
                website_url: Default::default(),
            }
        }
    }

    ///`TransactionIncludesResponseRepeatingTransaction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "guid": {
    ///      "examples": [
    ///        "RPT-065b8b1d-826a-45ce-8487-60ca1510e72a"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "recurrence_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "EVERY_OTHER_WEEK"
    ///      ]
    ///    },
    ///    "repeating_transaction_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "BILL",
    ///        "SUBSCRIPTION",
    ///        "INCOME",
    ///        "UNKNOWN"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionIncludesResponseRepeatingTransaction {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recurrence_type:
            ::std::option::Option<TransactionIncludesResponseRepeatingTransactionRecurrenceType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub repeating_transaction_type: ::std::option::Option<
            TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType,
        >,
    }

    impl ::std::convert::From<&TransactionIncludesResponseRepeatingTransaction>
        for TransactionIncludesResponseRepeatingTransaction
    {
        fn from(value: &TransactionIncludesResponseRepeatingTransaction) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionIncludesResponseRepeatingTransaction {
        fn default() -> Self {
            Self {
                guid: Default::default(),
                recurrence_type: Default::default(),
                repeating_transaction_type: Default::default(),
            }
        }
    }

    ///`TransactionIncludesResponseRepeatingTransactionRecurrenceType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "EVERY_OTHER_WEEK"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransactionIncludesResponseRepeatingTransactionRecurrenceType {
        #[serde(rename = "EVERY_OTHER_WEEK")]
        EveryOtherWeek,
    }

    impl ::std::convert::From<&Self> for TransactionIncludesResponseRepeatingTransactionRecurrenceType {
        fn from(value: &TransactionIncludesResponseRepeatingTransactionRecurrenceType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TransactionIncludesResponseRepeatingTransactionRecurrenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EveryOtherWeek => f.write_str("EVERY_OTHER_WEEK"),
            }
        }
    }

    impl ::std::str::FromStr for TransactionIncludesResponseRepeatingTransactionRecurrenceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "EVERY_OTHER_WEEK" => Ok(Self::EveryOtherWeek),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for TransactionIncludesResponseRepeatingTransactionRecurrenceType
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for TransactionIncludesResponseRepeatingTransactionRecurrenceType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for TransactionIncludesResponseRepeatingTransactionRecurrenceType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "BILL",
    ///    "SUBSCRIPTION",
    ///    "INCOME",
    ///    "UNKNOWN"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType {
        #[serde(rename = "BILL")]
        Bill,
        #[serde(rename = "SUBSCRIPTION")]
        Subscription,
        #[serde(rename = "INCOME")]
        Income,
        #[serde(rename = "UNKNOWN")]
        Unknown,
    }

    impl ::std::convert::From<&Self>
        for TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType
    {
        fn from(
            value: &TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display
        for TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bill => f.write_str("BILL"),
                Self::Subscription => f.write_str("SUBSCRIPTION"),
                Self::Income => f.write_str("INCOME"),
                Self::Unknown => f.write_str("UNKNOWN"),
            }
        }
    }

    impl ::std::str::FromStr
        for TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "BILL" => Ok(Self::Bill),
                "SUBSCRIPTION" => Ok(Self::Subscription),
                "INCOME" => Ok(Self::Income),
                "UNKNOWN" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for TransactionIncludesResponseRepeatingTransactionRepeatingTransactionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TransactionResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "examples": [
    ///        "ACT-0af29528-bb91-447f-b5de-85c1c42593e5"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "account_id": {
    ///      "examples": [
    ///        "FdvkkAgLS0nbDNUujrblz6rYDSl5w-tTLwYRgIxe7jw"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "amount": {
    ///      "examples": [
    ///        5003.9
    ///      ],
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "category": {
    ///      "examples": [
    ///        "Paycheck"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-982ea9e6-3f0e-0c5b-611b-6657a10ba819"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "check_number_string": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2024-12-20T18:52:36Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "currency_code": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "date": {
    ///      "examples": [
    ///        "2024-12-20"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "MX Technologies"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "extended_transaction_type": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "TRN-429ad9fe-a1d2-4559-8590-885b2603f0e1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "1734681600000-178fa8095c154a55b9172f977b4c5f9a-0"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_bill_pay": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_direct_deposit": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_expense": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_fee": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_income": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_international": {
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_manual": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_overdraft_fee": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_payroll_advance": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_recurring": {
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_subscription": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "latitude": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "localized_description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "localized_memo": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "longitude": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_guid": {
    ///      "examples": [
    ///        "MBR-78b14c5f-7297-4fb5-a966-65ac45f74d8"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "member_is_managed_by_user": {
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "memo": {
    ///      "examples": [
    ///        "Transactions"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_category_code": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_guid": {
    ///      "examples": [
    ///        "MCH-8cc3b01a-1c52-47d4-970d-30f8ee5566f1"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "merchant_location_guid": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "original_description": {
    ///      "examples": [
    ///        "MX TECHNOLOGIES PAYMENT"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "posted_at": {
    ///      "examples": [
    ///        "2024-12-20T12:00:00Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "status": {
    ///      "examples": [
    ///        "POSTED"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "top_level_category": {
    ///      "examples": [
    ///        "Income"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transacted_at": {
    ///      "examples": [
    ///        "2024-12-20T12:00:00Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "examples": [
    ///        "CREDIT"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2024-12-20T18:52:38Z"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-ef7a82f6-d6c1-42c4-9061-bdece5c4d44e"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub check_number_string: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub currency_code: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extended_transaction_type: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_bill_pay: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_direct_deposit: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_expense: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_income: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_international: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_manual: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_overdraft_fee: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_payroll_advance: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_recurring: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_subscription: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub latitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub localized_memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub longitude: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub member_is_managed_by_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_category_code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub merchant_location_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub original_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub posted_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub status: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub top_level_category: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transacted_at: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionResponse> for TransactionResponse {
        fn from(value: &TransactionResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionResponse {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                account_id: Default::default(),
                amount: Default::default(),
                category: Default::default(),
                category_guid: Default::default(),
                check_number_string: Default::default(),
                created_at: Default::default(),
                currency_code: Default::default(),
                date: Default::default(),
                description: Default::default(),
                extended_transaction_type: Default::default(),
                guid: Default::default(),
                id: Default::default(),
                is_bill_pay: Default::default(),
                is_direct_deposit: Default::default(),
                is_expense: Default::default(),
                is_fee: Default::default(),
                is_income: Default::default(),
                is_international: Default::default(),
                is_manual: Default::default(),
                is_overdraft_fee: Default::default(),
                is_payroll_advance: Default::default(),
                is_recurring: Default::default(),
                is_subscription: Default::default(),
                latitude: Default::default(),
                localized_description: Default::default(),
                localized_memo: Default::default(),
                longitude: Default::default(),
                member_guid: Default::default(),
                member_is_managed_by_user: Default::default(),
                memo: Default::default(),
                merchant_category_code: Default::default(),
                merchant_guid: Default::default(),
                merchant_location_guid: Default::default(),
                metadata: Default::default(),
                original_description: Default::default(),
                posted_at: Default::default(),
                status: Default::default(),
                top_level_category: Default::default(),
                transacted_at: Default::default(),
                type_: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`TransactionResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction": {
    ///      "$ref": "#/components/schemas/TransactionResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction: ::std::option::Option<TransactionResponse>,
    }

    impl ::std::convert::From<&TransactionResponseBody> for TransactionResponseBody {
        fn from(value: &TransactionResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionResponseBody {
        fn default() -> Self {
            Self {
                transaction: Default::default(),
            }
        }
    }

    ///`TransactionRuleCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "category_guid",
    ///    "match_description"
    ///  ],
    ///  "properties": {
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-b1de2a04-db08-b6ed-f6fe-ca2f5b11c2d0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Wal-mart food storage"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "match_description": {
    ///      "examples": [
    ///        "Wal-mart"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRuleCreateRequest {
        pub category_guid: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub match_description: ::std::string::String,
    }

    impl ::std::convert::From<&TransactionRuleCreateRequest> for TransactionRuleCreateRequest {
        fn from(value: &TransactionRuleCreateRequest) -> Self {
            value.clone()
        }
    }

    ///`TransactionRuleCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction_rule": {
    ///      "$ref": "#/components/schemas/TransactionRuleCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRuleCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_rule: ::std::option::Option<TransactionRuleCreateRequest>,
    }

    impl ::std::convert::From<&TransactionRuleCreateRequestBody> for TransactionRuleCreateRequestBody {
        fn from(value: &TransactionRuleCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionRuleCreateRequestBody {
        fn default() -> Self {
            Self {
                transaction_rule: Default::default(),
            }
        }
    }

    ///`TransactionRuleResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-b1de2a04-db08-b6ed-f6fe-ca2f5b11c2d0"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "created_at": {
    ///      "examples": [
    ///        "2018-10-02T22:00:50+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Wal-mart food storage"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "TXR-a080e0f9-a2d4-4d6f-9e03-672cc357a4d3"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "match_description": {
    ///      "examples": [
    ///        "Wal-mart"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "updated_at": {
    ///      "examples": [
    ///        "2018-10-02T23:54:40+00:00"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_guid": {
    ///      "examples": [
    ///        "USR-22fc3203-b3e6-8340-43db-8e50b2f56995"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRuleResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub match_description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub updated_at: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_guid: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionRuleResponse> for TransactionRuleResponse {
        fn from(value: &TransactionRuleResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionRuleResponse {
        fn default() -> Self {
            Self {
                category_guid: Default::default(),
                created_at: Default::default(),
                description: Default::default(),
                guid: Default::default(),
                match_description: Default::default(),
                updated_at: Default::default(),
                user_guid: Default::default(),
            }
        }
    }

    ///`TransactionRuleResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction_rule": {
    ///      "$ref": "#/components/schemas/TransactionRuleResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRuleResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_rule: ::std::option::Option<TransactionRuleResponse>,
    }

    impl ::std::convert::From<&TransactionRuleResponseBody> for TransactionRuleResponseBody {
        fn from(value: &TransactionRuleResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionRuleResponseBody {
        fn default() -> Self {
            Self {
                transaction_rule: Default::default(),
            }
        }
    }

    ///`TransactionRuleUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "category_guid": {
    ///      "examples": [
    ///        "CAT-b1de2a04-db08-b6ed-f6fe-ca2f5b11c2d0"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "Wal-mart food storage"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "match_description": {
    ///      "examples": [
    ///        "Wal-mart"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRuleUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub match_description: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionRuleUpdateRequest> for TransactionRuleUpdateRequest {
        fn from(value: &TransactionRuleUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionRuleUpdateRequest {
        fn default() -> Self {
            Self {
                category_guid: Default::default(),
                description: Default::default(),
                match_description: Default::default(),
            }
        }
    }

    ///`TransactionRuleUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction_rule": {
    ///      "$ref": "#/components/schemas/TransactionRuleUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRuleUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_rule: ::std::option::Option<TransactionRuleUpdateRequest>,
    }

    impl ::std::convert::From<&TransactionRuleUpdateRequestBody> for TransactionRuleUpdateRequestBody {
        fn from(value: &TransactionRuleUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionRuleUpdateRequestBody {
        fn default() -> Self {
            Self {
                transaction_rule: Default::default(),
            }
        }
    }

    ///`TransactionRulesResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "transaction_rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionRuleResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionRulesResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transaction_rules: ::std::vec::Vec<TransactionRuleResponse>,
    }

    impl ::std::convert::From<&TransactionRulesResponseBody> for TransactionRulesResponseBody {
        fn from(value: &TransactionRulesResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionRulesResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                transaction_rules: Default::default(),
            }
        }
    }

    ///`TransactionUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "category_guid": {
    ///      "type": "string"
    ///    },
    ///    "date": {
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "examples": [
    ///        "new description"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "memo": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub category_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memo: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TransactionUpdateRequest> for TransactionUpdateRequest {
        fn from(value: &TransactionUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionUpdateRequest {
        fn default() -> Self {
            Self {
                category_guid: Default::default(),
                date: Default::default(),
                description: Default::default(),
                memo: Default::default(),
            }
        }
    }

    ///`TransactionUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "transaction": {
    ///      "$ref": "#/components/schemas/TransactionUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction: ::std::option::Option<TransactionUpdateRequest>,
    }

    impl ::std::convert::From<&TransactionUpdateRequestBody> for TransactionUpdateRequestBody {
        fn from(value: &TransactionUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionUpdateRequestBody {
        fn default() -> Self {
            Self {
                transaction: Default::default(),
            }
        }
    }

    ///`TransactionsResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionsResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transactions: ::std::vec::Vec<TransactionResponse>,
    }

    impl ::std::convert::From<&TransactionsResponseBody> for TransactionsResponseBody {
        fn from(value: &TransactionsResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionsResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                transactions: Default::default(),
            }
        }
    }

    ///`TransactionsResponseBodyIncludes`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TransactionIncludesResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TransactionsResponseBodyIncludes {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transactions: ::std::vec::Vec<TransactionIncludesResponse>,
    }

    impl ::std::convert::From<&TransactionsResponseBodyIncludes> for TransactionsResponseBodyIncludes {
        fn from(value: &TransactionsResponseBodyIncludes) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TransactionsResponseBodyIncludes {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                transactions: Default::default(),
            }
        }
    }

    ///`UpdateGoalRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "account_guid": {
    ///      "description": "Unique identifier of the account for the goal.",
    ///      "examples": [
    ///        "ACT-4e431124-4a29-abf9-f059-ab232ac14dbf"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "description": "Amount of the goal.",
    ///      "examples": [
    ///        4500.5
    ///      ],
    ///      "type": "number"
    ///    },
    ///    "completed_at": {
    ///      "description": "Date and time the goal was completed.",
    ///      "examples": [
    ///        "2015-06-19T10:37:04-06:00"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "goal_type_name": {
    ///      "description": "The goal type.",
    ///      "examples": [
    ///        "PAYOFF"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "has_been_spent": {
    ///      "description": "Determines if the goal has been spent.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "is_complete": {
    ///      "description": "Determines if the goal is complete.",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "meta_type_name": {
    ///      "description": "The category of the goal.",
    ///      "examples": [
    ///        "VACATION"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "metadata": {
    ///      "description": "Additional information a partner can store on the
    /// goal.",
    ///      "examples": [
    ///        "Additional information"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the goal.",
    ///      "examples": [
    ///        "Save for Europe"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "position": {
    ///      "description": "The priority of the goal in relation to multiple
    /// goals.",
    ///      "examples": [
    ///        3
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "targeted_to_complete_at": {
    ///      "description": "Date and time the goal is to complete. Intended for
    /// users to set their own goal completion dates.",
    ///      "examples": [
    ///        "2026-12-08 00:00:00.000000"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateGoalRequest {
        ///Unique identifier of the account for the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub amount: ::std::option::Option<f64>,
        ///Date and time the goal was completed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub completed_at: ::std::option::Option<::std::string::String>,
        ///The goal type.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goal_type_name: ::std::option::Option<::std::string::String>,
        ///Determines if the goal has been spent.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub has_been_spent: ::std::option::Option<bool>,
        ///Determines if the goal is complete.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_complete: ::std::option::Option<bool>,
        ///The category of the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub meta_type_name: ::std::option::Option<::std::string::String>,
        ///Additional information a partner can store on the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
        ///The name of the goal.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///The priority of the goal in relation to multiple goals.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub position: ::std::option::Option<i64>,
        ///Date and time the goal is to complete. Intended for users to set
        /// their own goal completion dates.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub targeted_to_complete_at: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateGoalRequest> for UpdateGoalRequest {
        fn from(value: &UpdateGoalRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateGoalRequest {
        fn default() -> Self {
            Self {
                account_guid: Default::default(),
                amount: Default::default(),
                completed_at: Default::default(),
                goal_type_name: Default::default(),
                has_been_spent: Default::default(),
                is_complete: Default::default(),
                meta_type_name: Default::default(),
                metadata: Default::default(),
                name: Default::default(),
                position: Default::default(),
                targeted_to_complete_at: Default::default(),
            }
        }
    }

    ///`UpdateGoalRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "goal": {
    ///      "$ref": "#/components/schemas/UpdateGoalRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateGoalRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub goal: ::std::option::Option<UpdateGoalRequest>,
    }

    impl ::std::convert::From<&UpdateGoalRequestBody> for UpdateGoalRequestBody {
        fn from(value: &UpdateGoalRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateGoalRequestBody {
        fn default() -> Self {
            Self {
                goal: Default::default(),
            }
        }
    }

    ///`UserCreateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "email@provider.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "My-Unique-ID"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_disabled": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "{\\\"type\\\": \\\"individual\\\", \\\"status\\\":
    /// \\\"preferred\\\"}"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserCreateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_disabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserCreateRequest> for UserCreateRequest {
        fn from(value: &UserCreateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UserCreateRequest {
        fn default() -> Self {
            Self {
                email: Default::default(),
                id: Default::default(),
                is_disabled: Default::default(),
                metadata: Default::default(),
            }
        }
    }

    ///`UserCreateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "user": {
    ///      "$ref": "#/components/schemas/UserCreateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserCreateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user: ::std::option::Option<UserCreateRequest>,
    }

    impl ::std::convert::From<&UserCreateRequestBody> for UserCreateRequestBody {
        fn from(value: &UserCreateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UserCreateRequestBody {
        fn default() -> Self {
            Self {
                user: Default::default(),
            }
        }
    }

    ///`UserResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "email@provider.com"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "guid": {
    ///      "examples": [
    ///        "USR-d74cb14f-fd0a-449f-991b-e0362a63d9c6"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "My-Unique-ID"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_disabled": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": [
    ///        "boolean",
    ///        "null"
    ///      ]
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "{\\\"first_name\\\": \\\"Steven\\\", \\\"last_name\\\":
    /// \\\"Universe\\\"}"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub guid: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_disabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserResponse> for UserResponse {
        fn from(value: &UserResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UserResponse {
        fn default() -> Self {
            Self {
                email: Default::default(),
                guid: Default::default(),
                id: Default::default(),
                is_disabled: Default::default(),
                metadata: Default::default(),
            }
        }
    }

    ///`UserResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "user": {
    ///      "$ref": "#/components/schemas/UserResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user: ::std::option::Option<UserResponse>,
    }

    impl ::std::convert::From<&UserResponseBody> for UserResponseBody {
        fn from(value: &UserResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UserResponseBody {
        fn default() -> Self {
            Self {
                user: Default::default(),
            }
        }
    }

    ///`UserUpdateRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "email": {
    ///      "examples": [
    ///        "email@provider.com"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "examples": [
    ///        "My-Unique-ID"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "is_disabled": {
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "metadata": {
    ///      "examples": [
    ///        "{\\\"first_name\\\": \\\"Steven\\\", \\\"last_name\\\":
    /// \\\"Universe\\\"}"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserUpdateRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_disabled: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub metadata: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserUpdateRequest> for UserUpdateRequest {
        fn from(value: &UserUpdateRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UserUpdateRequest {
        fn default() -> Self {
            Self {
                email: Default::default(),
                id: Default::default(),
                is_disabled: Default::default(),
                metadata: Default::default(),
            }
        }
    }

    ///`UserUpdateRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "user": {
    ///      "$ref": "#/components/schemas/UserUpdateRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserUpdateRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user: ::std::option::Option<UserUpdateRequest>,
    }

    impl ::std::convert::From<&UserUpdateRequestBody> for UserUpdateRequestBody {
        fn from(value: &UserUpdateRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UserUpdateRequestBody {
        fn default() -> Self {
            Self {
                user: Default::default(),
            }
        }
    }

    ///`UsersResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "pagination": {
    ///      "$ref": "#/components/schemas/PaginationResponse"
    ///    },
    ///    "users": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UsersResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pagination: ::std::option::Option<PaginationResponse>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub users: ::std::vec::Vec<UserResponse>,
    }

    impl ::std::convert::From<&UsersResponseBody> for UsersResponseBody {
        fn from(value: &UsersResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UsersResponseBody {
        fn default() -> Self {
            Self {
                pagination: Default::default(),
                users: Default::default(),
            }
        }
    }

    ///`VcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "verifiableCredential": {
    ///      "examples": [
    ///        "feJgbGciOiJFZERTQSEsImtpFCI6ImRpZDpksHR6c4E6MTNkdzdqeWc0NGVqd2NkZjhpcWNzZWg3amN6NTF3ajZmanhib29qNDFpcGVnNzZlbyMwIiwidHlwIjoiSldUIn0.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSJdLCJpZCI6Imh0dHBzOi8vYXBpLnNhbmQuaW50ZXJuYWwubXgvdmMvdXNlcnMvVVNSLTNlYTdjYzMxLWVkZDYtNDQxNy05YjM1LWRlZTZlMjQ4NDI1Yi9tZW1iZXJzL01CUi1jYzUxNDViZi02M2Q5LTQ5OGYtODc3Mi1lNGVmMzI0MWNjYjYvYWNjb3VudHMiLCJ0eXBlIjpbIlZlcmlmaWFibGVDcmVkZW50aWFsIiwiRmluYW5jaWFsQWNjb3VudENyZWRlbnRpYWwiXSwiaXNzdWVyIjoiZGlkOmRodDpzYTcxM2R3N2p5ZzQ0ZWp3Y2RmOGlxY3NlaDdqY3o1MXdqNmZqeGJvb2o0MWlwZWc3NmVvIiwiaXNzdWFuY2VEYXRlIjoiMjAyNC0wMy0wMVQxODo0MjoxOVoiLCJjcmVkZW50aWFsU3ViamVjdCI6eyJhY2NvdW50cyI6W3sibG9jQWNjb3VudCI6eyJhY2NvdW52SWQiOeABQ1RtODRhMDEyNjgtNTdkMC00YTI4LWEwYzEtZTcyYWRyNDA5NbJkIiwiYWNjb3VudFR5cFUiOiJDUkVESVRDQVJEIiwiYWNjb3VudE51bWJlciI6IjM0OTcyNTM0NCIsImFjY291bnROdW1iZXJEaXNwbGF5IjoiKioqKjUzNDQiLCJwcm9kdWN0TmFtZSI6bnVsbCwibmlja25hbWUiOm51bGwsInN0YXR1cyI6Ik9QRU4iLCJhY2NvdW50T3BlbkRhdGUiOiIyMDIyLTA3LTExVDE1OjQwOjQwWiIsImFjY291bnRDbG9zZWREYXRlIjpudWxsLCJjdXJyZW5jeSI6eyJjdXJyZW5jeVJhdGUiOm51bGwsImN1cnJlbmN5Q29kZSI6bnVsbCwib3JpZ2luYWxDdXJyZW5jeUNvZGUiOm51bGx9LCJmaUF0dHJpYnV0ZXMiOlt7Im5hbWUiOiJtZW1iZXJfZ3VpZCIsInZhbHVlIjoiTUJSLWNjNTE0NWJmLTYzZDktNDk4Zi04NzcyLWU0ZWYzMjQxY2NiNiJ9LHsibmFtZSI6Imluc3RpdHV0aW9uX2d1aWQiLCJ2YWx1ZSI6IklOUy1mMWEzMjg1ZC1lODU1LWI2OGYtNmFhNy04YWU3NzVjMGUwZTkifSx7Im5hbWUiOiJleHRlcm5hbF9ndWlkIiwidmFsdWUiOiJhY2NvdW50LWY3ZTg3ZWZmLTA2YzAtNDZhMS1iODAwLTUxOTI3ODM2MjFhOSJ9XSwicm91dGluZ1RyYW5zaXROdW1iZXIiOm51bGwsImJhbGFuY2VUeXBlIjoiTElBQklMSVRZIiwiaW50ZXJlc3RSYXRlIjpudWxsLCJsYXN0QWN0aXZpdHlEYXRlIjoiMjAyMi0wNy0xMVQxNTo0MDo0MFoiLCJiYWxhbmNlQXNPZiI6IjIwMjItMDctMTFUMTU6NDA6NDBaIiwiY3JlZGl0TGluZSI6bnVsbCwiYXZhaWxhYmxlQ3JlZGl0IjoxMzAwMC4wLCJuZXh0UGF5bWVudERhdGUiOm51bGwsInByaW5jaXBhbEJhbGFuY2UiOm51bGwsImN1cnJlbnRCYWxhbmNlIjoxMDAwLjAsIm1pbmltdW1QYXltZW50QW1vdW50IjpudWxsLCJwdXJjaGFzZXNBcHIiOm51bGx9fSx7ImRlcG9zaXRBY2NvdW50Ijp7ImFjY291bnRJZCI6IkFDVC05NmYzMGQ2Ny0xZTA1LTRhNGItOWZkNS01NzFlYmUzZGU5NWMiLCJhY2NvdW50VHlwZSI6IkNIRUNLSU5HIiwiYWNjb3VudE51bWJlciI6Ijg0NTUzNTE2MSIsImFjY291bnROdW1iZXJEaXNwbGF5IjoiKioqKjUxNjEiLCJwcm9kdWN0TmFtZSI6bnVsbCwibmlja25hbWUiOm51bGwsInN0YXR1cyI6Ik9QRU4iLCJhY2NvdW50T3BlbkRhdGUiOiIyMDIyLTA3LTExVDE1OjQwOjQwWiIsImFjY291bnRDbG9zZWREYXRlIjpudWxsLCJjdXJyZW5jeSI6eyJjdXJyZW5jeVJhdGUiOm51bGwsImN1cnJlbmN5Q29kZSI6bnVsbCwib3JpZ2luYWxDdXJyZW5jeUNvZGUiOm51bGx9LCJmaUF0dHJpYnV0ZXMiOlt7Im5hbWUiOiJtZW1iZXJfZ3VpZCIsInZhbHVlIjoiTUJSLWNjNTE0NWJmLTYzZDktNDk4Zi04NzcyLWU0ZWYzMjQxY2NiNiJ9LHsibmFtZSI6Imluc3RpdHV0aW9uX2d1aWQiLCJ2YWx1ZSI6IklOUy1mMWEzMjg1ZC1lODU1LWI2OGYtNmFhNy04YWU3NzVjMGUwZTkifSx7Im5hbWUiOiJleHRlcm5hbF9ndWlkIiwidmFsdWUiOiJhY2NvdW50LWM2ZTc2MjQ0LTg4NjAtNDY0OS05ZDg1LTY1MGQzYWY5ZmViZSJ9XSwicm91dGluZ1RyYW5zaXROdW1iZXIiOm51bGwsImJhbGFuY2VUeXBlIjoiQVNTRVQiLCJpbnRlcmVzdFJhdGUiOm51bGwsImxhc3RBY3Rpdml0eURhdGUiOiIyMDIyLTA3LTExVDE1OjQwOjQwWiIsImJhbGFuY2VBc09mIjoiMjAyMi0wNy0xMVQxNTo0MDo0MFoiLCJjdXJyZW50QmFsYW5jZSI6MTAwMC4wLCJvcGVuaW5nRGF5QmFsYW5jZSI6bnVsbCwiYXZhaWxhYmxlQmFsYW5jZSI6MTAwMC4wLCJhbm51YWxQZXJjZW50YWdlWWllbGQiOm51bGwsIm1hdHVyaXR5RGF0ZSI6bnVsbH19LHsiZGVwb3NpdEFjY291bnQiOnsiYWNjb3VudElkIjoiQUNULWI4MjZlNGMyLTZkNjktNDVkNy1hMTM5LWJlNTY0NDFkNmE1OCIsImFjY291bnRUeXBlIjoiU0FWSU5HUyIsImFjY291bnROdW1iZXIiOiI1OTE4NzE2NjgiLCJhY2NvdW50TnVtYmVyRGlzcGxheSI6IioqKioxNjY4IiwicHJvZHVjdE5hbWUiOm51bGwsIm5pY2tuYW1lIjpudWxsLCJzdGF0dXMiOiJPUEVOIiwiYWNjb3VudE9wZW5EYXRlIjoiMjAyMi0wNy0xMVQxNTo0MDo0MFoiLCJhY2NvdW50Q2xvc2VkRGF0ZSI6bnVsbCwiY3VycmVuY3kiOnsiY3VycmVuY3lSYXRlIjpudWxsLCJjdXJyZW5jeUNvZGUiOm51bGwsIm9yaWdpbmFsQ3VycmVuY3lDb2RlIjpudWxsfSwiZmlBdHRyaWJ1dGVzIjpbeyJuYW1lIjoibWVtYmVyX2d1aWQiLCJ2YWx1ZSI6Ik1CUi1jYzUxNDViZi02M2Q5LTQ5OGYtODc3Mi1lNGVmMzI0MWNjYjYifSx7Im5hbWUiOiJpbnN0aXR1dGlvbl9ndWlkIiwidmFsdWUiOiJJTlMtZjFhMzI4NWQtZTg1NS1iNjhmLTZhYTctOGFlNzc1YzBlMGU5In0seyJuYW1lIjoiZXh0ZXJuYWxfZ3VpZCIsInZhbHVlIjoiYWNjb3VudC1kOTIyNTA4OC1hOTM2LTRkNjctOGQyYy0wY2EyYzgwOGYxMTYifV0sInJvdXRpbmdUcmFuc2l0TnVtYmVyIjpudWxsLCJiYWxhbmNlVHlwZSI6IkFTU0VUIiwiaW50ZXJlc3RSYXRlIjpudWxsLCJsYXN0QWN0aXZpdHlEYXRlIjoiMjAyMi0wNy0xMVQxNTo0MDo0MFoiLCJiYWxhbmNlQXNPZiI6IjIwMjItMDctMTFUMTU6NDA6NDBaIiwiY3VycmVudEJhbGFuY2UiOjEwMDAuMCwib3BlbmluZ0RheUJhbGFuY2UiOm51bGwsImF2YWlsYWJsZUJhbGFuY2UiOjEwMDAuMCwiYW5udWFsUGVyY2VudGFnZVlpZWxkIjpudWxsLCJtYXR1cml0eURhdGUiOm51bGx9fV0sImlkIjoiVVNSLTNlYTdjYzMxLWVkZDYtNDQxNy05YjM1LWRlZTZlMjQ4NDI1YiJ9fSwiaXNzIjoiZGlkOmRodDpzYTcxM2R3N2p5ZzQ0ZWp3Y2RmOGlxY3NlaDdqY3o1MXdqNmZqeGJvb2o0MWlwZWc3NmVvIiwiaWF0IjoxNzA5MzE4NTM5LCJqdGkiOiJodHRwczovL2FwaS5zYW5kLmludGVybmFsLm14L3ZjL3VzZXJzL1VTUi0zZWE3Y2MzMS1lZGQ2LTQ0MTctOWIzNS1kZWU2ZTI0ODQyNWIvbWVtYmVycy9NQlItY2M1MTQ1YmYtNjNkOS00OThmLTg3NzItZTRlZjMyNDFjY2I2L2FjY291bnRzIiwic3ViIjoiVVNSLTNlYTdjYzMxLWVkZDYtNDQxNy05YjM1LWRlZTZlMjQ4NDI1YiJ9._CiFkwbuhKxwwIehEQ1opsi-9NSoIwDqD2HFMw1ROKNuJPdepTXFEd_RDFbbg7lFj05vBXPUL7y9eVVgZXTvDw"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VcResponse {
        #[serde(
            rename = "verifiableCredential",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub verifiable_credential: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VcResponse> for VcResponse {
        fn from(value: &VcResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VcResponse {
        fn default() -> Self {
            Self {
                verifiable_credential: Default::default(),
            }
        }
    }

    ///`WidgetRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "widget_type"
    ///  ],
    ///  "properties": {
    ///    "client_redirect_url": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This determines the redirect destination at the end of
    /// OAuth when used with `is_mobile_webview: true` or
    /// `oauth_referral_source: 'APP'`.\n",
    ///      "examples": [
    ///        "https://{yoursite.com}"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "color_scheme": {
    ///      "description": "This option can be passed to any `widget_type` but will not affect [legacy PFM widgets](products/experience/pfm/legacy-widget-overviews/). Load the widget with the specified `color_scheme`; options are `light`, `browser` (respects user's browser setting), and `dark`. Defaults to `light`.",
    ///      "examples": [
    ///        "light"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "connections_use_case_filter": {
    ///      "description": "To use this parameter, you must also set
    /// `use_cases` in the same request. If `connections_use_case_filter` is set
    /// to `true`, the Connections Widget will only show connections (members)
    /// with the `use_cases` you set in the same request. For some examples, see
    /// [Filter Connections](/products/experience/pfm/widget-overviews/
    /// connections-widget#example-1).",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "current_institution_code": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. Load the widget into the credential view for the
    /// specified institution.\n",
    ///      "examples": [
    ///        "mxbank"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "current_institution_guid": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. Load the widget into the credential view for the
    /// specified institution.\n",
    ///      "examples": [
    ///        "INS-f1a3285d-e855-b61f-6aa7-8ae575c0e0e9"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "current_member_guid": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. Load the widget into a specific member that contains
    /// an error or requires multifactor authentication. The widget will
    /// determine the best view to load based on the member's current state.
    /// `current_member_guid` takes precedence over `current_institution_code`
    /// and `current_institution_guid`.\n",
    ///      "examples": [
    ///        "MBR-7c6f361b-e582-15b6-60c0-358f12466b4b"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "disable_background_agg": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This determines whether background aggregation is
    /// enabled or disabled for the member created by the Connect Widget.
    /// Defaults to `false` in `aggregation` mode and `true` in `verification`
    /// mode. A global default for all members can be set by reaching out to
    /// MX.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "disable_institution_search": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This determines whether the institution search is
    /// displayed within the Connect Widget. This option must be used with
    /// `current_institution_code`, `current_instituion_guid`, or
    /// `current_member_guid`. When set to `true`, the institution search
    /// feature will be disabled and end users will not be able to navigate to
    /// it. Defaults to `false`.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "enable_app2app": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This indicates whether OAuth app2app behavior is
    /// enabled for institutions that support it. Defaults to `true`. When set
    /// to `false`, the widget will **not** direct the end user to the
    /// institution's mobile application. This setting is not persistent. This
    /// setting currently only affects Chase institutions.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "include_identity": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This determines whether an account owner
    /// identification (AOI, previously called identity verification) is run in
    /// addition to the process specified by the `mode`. Defaults to `false`.
    /// This can be set in either `aggregation` or `verification` mode. The AOI
    /// runs after the primary process is complete.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "include_transactions": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This determines whether transaction data are
    /// retrieved. Defaults to `true` in aggregation mode and `false` in
    /// verification mode. This can be set in either `aggregation` or
    /// `verification` mode. This option does not affect future foreground or
    /// background aggregations.\n",
    ///      "examples": [
    ///        true
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "insight_guid": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `pulse_widget`. Set this to the insight guid you want to appear at the
    /// top of the insights feed.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "is_mobile_webview": {
    ///      "description": "This option is for all `widget_type`s. This
    /// configures the widget to render in a mobile WebView. JavaScript event
    /// postMessages are replaced with URL updates.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "iso_country_code": {
    ///      "description": "An array of strings that filters institutions in
    /// the widget by the specified country code. Acceptable codes include `US`,
    /// `CA`, and `MX` (Mexico).\n",
    ///      "examples": [
    ///        [
    ///          "US",
    ///          "CA"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "microwidget_instance_id": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `micro_pulse_carousel_widget`. Set this to a unique value for each
    /// instance of the Micro Widget. This lets us collect unique data for each
    /// instance of the widget.\n",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "mode": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. `mode` is the most important option for the Connect
    /// Widget. This determines what kind of process Connect will run, which
    /// affects how you should set many other options. Defaults to
    /// `aggregation`. `aggregation` mode retrieves account and transaction
    /// data; in other words, this runs a standard aggregation. `verification`
    /// mode retrieves account numbers and routing/transit numbers; in other
    /// words, it runs an Instant Account Verification (IAV). By default,
    /// verification mode does not retrieve transaction data; this default can
    /// be modified with secondary options. By default, background aggregation
    /// is disabled for all members created in verification mode; this default
    /// can be modified with secondary options.\n",
    ///      "examples": [
    ///        "aggregation"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "oauth_referral_source": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This determines how MX will respond to the result of
    /// an OAuth flow. When set to `APP`, MX will redirect to the URI specified
    /// in the `ui_message_webview_url_scheme`. When set to `BROWSER`, MX will
    /// send a postMessage but not redirect. If `is_mobile_webview` is `true`,
    /// this defaults to `APP`. If false, it defaults to `BROWSER`.\n",
    ///      "examples": [
    ///        "BROWSER"
    ///      ],
    ///      "type": "string"
    ///    },
    ///    "ui_message_version": {
    ///      "description": "This option is for all `widget_type`s. This
    /// determines which version of postMessage events are triggered. Defaults
    /// to 4. All new implementations must use version 4. Prior versions are
    /// deprecated.\n",
    ///      "examples": [
    ///        4
    ///      ],
    ///      "type": "integer"
    ///    },
    ///    "ui_message_webview_url_scheme": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. This is a client-defined scheme used in OAuth
    /// redirects in WebViews; also used in URL updates when these replace
    /// postMessages in WebViews. Defaults to `mx`.\n",
    ///      "type": "string"
    ///    },
    ///    "update_credentials": {
    ///      "description": "Only use this option if the `widget_type` is set to
    /// `connect_widget`. Load the widget into a view that allows them to update
    /// the current member. Optionally used with `current_member_guid`. This
    /// option should be used sparingly. The best practice is to use
    /// `current_member_guid` and let the widget resolve the issue.\n",
    ///      "examples": [
    ///        false
    ///      ],
    ///      "type": "boolean"
    ///    },
    ///    "use_cases": {
    ///      "description": "The use case that will be associated with any
    /// members created through the widget. Valid values are `PFM` and/or
    /// `MONEY_MOVEMENT`. This is **required** if you've met with MX, opted in
    /// to using this field, and are requesting a widget with a `widget_type` of
    /// `connect_widget` or `connections_widget`.",
    ///      "examples": [
    ///        [
    ///          "PFM"
    ///        ]
    ///      ],
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "MONEY_MOVEMENT",
    ///          "PFM"
    ///        ]
    ///      }
    ///    },
    ///    "widget_type": {
    ///      "description": "This determines which widget URL you'll
    /// receive.\n\nSee [Widget
    /// Types](/api-reference/platform-api/reference/widget-types) for a list of
    /// potential values. Additional request parameters may only apply to some
    /// widget types.\n",
    ///      "examples": [
    ///        "connect_widget"
    ///      ],
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WidgetRequest {
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This determines the redirect destination at the
        /// end of OAuth when used with `is_mobile_webview: true` or
        /// `oauth_referral_source: 'APP'`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub client_redirect_url: ::std::option::Option<::std::string::String>,
        ///This option can be passed to any `widget_type` but will not affect
        /// [legacy PFM
        /// widgets](products/experience/pfm/legacy-widget-overviews/). Load the
        /// widget with the specified `color_scheme`; options are `light`,
        /// `browser` (respects user's browser setting), and `dark`. Defaults to
        /// `light`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub color_scheme: ::std::option::Option<::std::string::String>,
        ///To use this parameter, you must also set `use_cases` in the same
        /// request. If `connections_use_case_filter` is set to `true`, the
        /// Connections Widget will only show connections (members) with the
        /// `use_cases` you set in the same request. For some examples, see
        /// [Filter Connections](/products/experience/pfm/widget-overviews/
        /// connections-widget#example-1).
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connections_use_case_filter: ::std::option::Option<bool>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. Load the widget into the credential view for the
        /// specified institution.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_institution_code: ::std::option::Option<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. Load the widget into the credential view for the
        /// specified institution.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_institution_guid: ::std::option::Option<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. Load the widget into a specific member that
        /// contains an error or requires multifactor authentication. The widget
        /// will determine the best view to load based on the member's current
        /// state. `current_member_guid` takes precedence over
        /// `current_institution_code` and `current_institution_guid`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub current_member_guid: ::std::option::Option<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This determines whether background aggregation is
        /// enabled or disabled for the member created by the Connect Widget.
        /// Defaults to `false` in `aggregation` mode and `true` in
        /// `verification` mode. A global default for all members can be set by
        /// reaching out to MX.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub disable_background_agg: ::std::option::Option<bool>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This determines whether the institution search is
        /// displayed within the Connect Widget. This option must be used with
        /// `current_institution_code`, `current_instituion_guid`, or
        /// `current_member_guid`. When set to `true`, the institution search
        /// feature will be disabled and end users will not be able to navigate
        /// to it. Defaults to `false`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub disable_institution_search: ::std::option::Option<bool>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This indicates whether OAuth app2app behavior is
        /// enabled for institutions that support it. Defaults to `true`. When
        /// set to `false`, the widget will **not** direct the end user to the
        /// institution's mobile application. This setting is not persistent.
        /// This setting currently only affects Chase institutions.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub enable_app2app: ::std::option::Option<bool>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This determines whether an account owner
        /// identification (AOI, previously called identity verification) is run
        /// in addition to the process specified by the `mode`. Defaults to
        /// `false`. This can be set in either `aggregation` or `verification`
        /// mode. The AOI runs after the primary process is complete.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub include_identity: ::std::option::Option<bool>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This determines whether transaction data are
        /// retrieved. Defaults to `true` in aggregation mode and `false` in
        /// verification mode. This can be set in either `aggregation` or
        /// `verification` mode. This option does not affect future foreground
        /// or background aggregations.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub include_transactions: ::std::option::Option<bool>,
        ///Only use this option if the `widget_type` is set to `pulse_widget`.
        /// Set this to the insight guid you want to appear at the top of the
        /// insights feed.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub insight_guid: ::std::option::Option<::std::string::String>,
        ///This option is for all `widget_type`s. This configures the widget to
        /// render in a mobile WebView. JavaScript event postMessages are
        /// replaced with URL updates.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_mobile_webview: ::std::option::Option<bool>,
        ///An array of strings that filters institutions in the widget by the
        /// specified country code. Acceptable codes include `US`, `CA`, and
        /// `MX` (Mexico).
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub iso_country_code: ::std::vec::Vec<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `micro_pulse_carousel_widget`. Set this to a unique value for each
        /// instance of the Micro Widget. This lets us collect unique data for
        /// each instance of the widget.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub microwidget_instance_id: ::std::option::Option<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. `mode` is the most important option for the
        /// Connect Widget. This determines what kind of process Connect will
        /// run, which affects how you should set many other options. Defaults
        /// to `aggregation`. `aggregation` mode retrieves account and
        /// transaction data; in other words, this runs a standard aggregation.
        /// `verification` mode retrieves account numbers and routing/transit
        /// numbers; in other words, it runs an Instant Account Verification
        /// (IAV). By default, verification mode does not retrieve transaction
        /// data; this default can be modified with secondary options. By
        /// default, background aggregation is disabled for all members created
        /// in verification mode; this default can be modified with secondary
        /// options.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This determines how MX will respond to the result
        /// of an OAuth flow. When set to `APP`, MX will redirect to the URI
        /// specified in the `ui_message_webview_url_scheme`. When set to
        /// `BROWSER`, MX will send a postMessage but not redirect. If
        /// `is_mobile_webview` is `true`, this defaults to `APP`. If false, it
        /// defaults to `BROWSER`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub oauth_referral_source: ::std::option::Option<::std::string::String>,
        ///This option is for all `widget_type`s. This determines which version
        /// of postMessage events are triggered. Defaults to 4. All new
        /// implementations must use version 4. Prior versions are deprecated.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ui_message_version: ::std::option::Option<i64>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. This is a client-defined scheme used in OAuth
        /// redirects in WebViews; also used in URL updates when these replace
        /// postMessages in WebViews. Defaults to `mx`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ui_message_webview_url_scheme: ::std::option::Option<::std::string::String>,
        ///Only use this option if the `widget_type` is set to
        /// `connect_widget`. Load the widget into a view that allows them to
        /// update the current member. Optionally used with
        /// `current_member_guid`. This option should be used sparingly. The
        /// best practice is to use `current_member_guid` and let the widget
        /// resolve the issue.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub update_credentials: ::std::option::Option<bool>,
        ///The use case that will be associated with any members created
        /// through the widget. Valid values are `PFM` and/or `MONEY_MOVEMENT`.
        /// This is **required** if you've met with MX, opted in to using this
        /// field, and are requesting a widget with a `widget_type` of
        /// `connect_widget` or `connections_widget`.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub use_cases: ::std::vec::Vec<WidgetRequestUseCasesItem>,
        ///This determines which widget URL you'll receive.
        ///
        ///See [Widget
        /// Types](/api-reference/platform-api/reference/widget-types) for a
        /// list of potential values. Additional request parameters may only
        /// apply to some widget types.
        pub widget_type: ::std::string::String,
    }

    impl ::std::convert::From<&WidgetRequest> for WidgetRequest {
        fn from(value: &WidgetRequest) -> Self {
            value.clone()
        }
    }

    ///`WidgetRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "widget_url": {
    ///      "$ref": "#/components/schemas/WidgetRequest"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WidgetRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub widget_url: ::std::option::Option<WidgetRequest>,
    }

    impl ::std::convert::From<&WidgetRequestBody> for WidgetRequestBody {
        fn from(value: &WidgetRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for WidgetRequestBody {
        fn default() -> Self {
            Self {
                widget_url: Default::default(),
            }
        }
    }

    ///`WidgetRequestUseCasesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "MONEY_MOVEMENT",
    ///    "PFM"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WidgetRequestUseCasesItem {
        #[serde(rename = "MONEY_MOVEMENT")]
        MoneyMovement,
        #[serde(rename = "PFM")]
        Pfm,
    }

    impl ::std::convert::From<&Self> for WidgetRequestUseCasesItem {
        fn from(value: &WidgetRequestUseCasesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WidgetRequestUseCasesItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::MoneyMovement => f.write_str("MONEY_MOVEMENT"),
                Self::Pfm => f.write_str("PFM"),
            }
        }
    }

    impl ::std::str::FromStr for WidgetRequestUseCasesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "MONEY_MOVEMENT" => Ok(Self::MoneyMovement),
                "PFM" => Ok(Self::Pfm),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WidgetRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WidgetRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WidgetRequestUseCasesItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WidgetResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "type": {
    ///      "examples": [
    ///        "connect_widget"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "url": {
    ///      "examples": [
    ///        "https://int-widgets.moneydesktop.com/md/connect/yxcdk7f1nb99jwApp34lA24m0AZ8rzprgmw17gm8z8h2AzjyAnd1rj42qfv42r3xnn07Amfwlg3j09hwp8bkq8tc5z21j33xjggmp2qtlpkz2v4gywfhfn31l44tx2w91bfc2thc58j4syqp0hgxcyvA4g7754hk7gjc56kt7tc36s45mmkdz2jqqqydspytmtr3dAb9jh6fkb24f3zkfpdjj0v77f0vmrtzvzxkmxz7dklsq8gd0gstkbhlw5bgpgc3m9mAtpAcr2w15gwy5xc4blgxppl42Avnm63291z3cyp0wm3lqgmvgzdAddct423gAdqxdlfx5d4mvc0ck2gt7ktqgks4vxq1pAy5"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "examples": [
    ///        "U-jeff-201709221210"
    ///      ],
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WidgetResponse {
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&WidgetResponse> for WidgetResponse {
        fn from(value: &WidgetResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for WidgetResponse {
        fn default() -> Self {
            Self {
                type_: Default::default(),
                url: Default::default(),
                user_id: Default::default(),
            }
        }
    }

    ///`WidgetResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "widget_url": {
    ///      "$ref": "#/components/schemas/WidgetResponse"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WidgetResponseBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub widget_url: ::std::option::Option<WidgetResponse>,
    }

    impl ::std::convert::From<&WidgetResponseBody> for WidgetResponseBody {
        fn from(value: &WidgetResponseBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for WidgetResponseBody {
        fn default() -> Self {
            Self {
                widget_url: Default::default(),
            }
        }
    }
}

#[derive(Clone, Debug)]
///Client for MX Platform API
///
///The MX Platform API is a powerful, fully-featured API designed to make
/// aggregating and enhancing financial data easy and reliable. It can
/// seamlessly connect your app or website to tens of thousands of financial
/// institutions.
///
///Just getting started? See our [use case guides](/use-cases/).
///
///
///Version: 20111101
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}

impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "20111101"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest::Client {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

impl ClientHooks<()> for &Client {}
#[allow(clippy::all)]
impl Client {
    ///Request an authorization code
    ///
    ///Clients use this endpoint to request an authorization code according to
    /// the parameters specified in the scope. Clients then pass this code to
    /// processors. Processor access is scoped only to the GUIDs and features
    /// specified in this request. Before requesting an authorization code which
    /// includes a member in the scope, clients must have verified that member.
    ///
    ///Sends a `POST` request to `/authorization_code`
    ///
    ///Arguments:
    /// - `body`: The scope for the authorization code.
    pub async fn request_authorization_code<'a>(
        &'a self,
        body: &'a types::AuthorizationCodeRequestBody,
    ) -> Result<ResponseValue<types::AuthorizationCodeResponseBody>, Error<()>> {
        let url = format!("{}/authorization_code", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "request_authorization_code",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read ACH Return
    ///
    ///:::warning
    ///The features documented here are in a beta state, and this documentation
    /// is considered draft material subject to frequent change. :::
    ///
    ///Use this endpoint to get an ACH return by its `guid` or `id`.
    ///
    ///
    ///Sends a `GET` request to `/ach_returns/{ach_return_guid}`
    ///
    ///Arguments:
    /// - `ach_return_guid`: The unique identifier (`guid`) for the ACH return.
    ///   Defined by MX.
    pub async fn read_ach_retrun<'a>(
        &'a self,
        ach_return_guid: &'a str,
    ) -> Result<ResponseValue<types::AchReturnResponseBody>, Error<()>> {
        let url = format!(
            "{}/ach_returns/{}",
            self.baseurl,
            encode_path(&ach_return_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_ach_retrun",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List ACH Returns
    ///
    ///:::warning
    ///The features documented here are in a beta state, and this documentation
    /// is considered draft material subject to frequent change. :::
    ///
    ///Use this endpoint to get all ACH returns.
    ///
    ///
    ///Sends a `GET` request to `/ach_returns`
    ///
    ///Arguments:
    /// - `institution_guid`: The identifier for the institution associated with
    ///   the ACH return. Defined by MX.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    /// - `resolved_status_at`: The date and time when the return was resolved
    ///   by the Receiving Financial Depository Institution (RDFI) in ISO 8601
    ///   format without timestamp
    /// - `return_code`: The associated ACH return code and notice of change
    ///   code. See [Return
    ///   Codes](/api-reference/platform-api/reference/ach-return-fields#
    ///   return-codes) for a complete list.
    /// - `return_status`: The status of the return. See [Return
    ///   Statuses](/api-reference/platform-api/reference/ach-return-fields#
    ///   return-status) for a complete list.
    /// - `returned_at`: The date and time when the return was reported by the
    ///   Receiving Financial Depository Institution (RDFI) in ISO 8601 format
    ///   without timestamp.
    pub async fn list_ach_retruns<'a>(
        &'a self,
        institution_guid: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        resolved_status_at: Option<&'a str>,
        return_code: Option<&'a str>,
        return_status: Option<&'a str>,
        returned_at: Option<&'a str>,
    ) -> Result<ResponseValue<types::AchReturnsResponseBody>, Error<()>> {
        let url = format!("{}/ach_returns", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "institution_guid",
                &institution_guid,
            ))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new(
                "resolved_status_at",
                &resolved_status_at,
            ))
            .query(&progenitor_client::QueryParam::new(
                "return_code",
                &return_code,
            ))
            .query(&progenitor_client::QueryParam::new(
                "return_status",
                &return_status,
            ))
            .query(&progenitor_client::QueryParam::new(
                "returned_at",
                &returned_at,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_ach_retruns",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create ACH Return
    ///
    ///:::warning
    ///The features documented here are in a beta state, and this documentation
    /// is considered draft material subject to frequent change. :::
    ///
    ///Use this endpoint to create an ACH return in our system.
    ///
    ///
    ///Sends a `POST` request to `/ach_returns`
    ///
    ///Arguments:
    /// - `body`: ACH return object to be created.
    pub async fn create_ach_return<'a>(
        &'a self,
        body: &'a types::AchReturnCreateRequestBody,
    ) -> Result<ResponseValue<types::AchReturnResponseBody>, Error<()>> {
        let url = format!("{}/ach_returns", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_ach_return",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List default categories
    ///
    ///Use this endpoint to retrieve a list of all the default categories and
    /// subcategories offered within the MX Platform API. In other words, each
    /// item in the returned list will have its `is_default` field set to
    /// `true`. There are currently 119 default categories and subcategories.
    /// Both the _list default categories_ and _list default categories by user_
    /// endpoints return the same results. The different routes are provided for
    /// convenience.
    ///
    ///Sends a `GET` request to `/categories/default`
    ///
    ///Arguments:
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_default_categories<'a>(
        &'a self,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::CategoriesResponseBody>, Error<()>> {
        let url = format!("{}/categories/default", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_default_categories",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a default category
    ///
    ///Use this endpoint to read the attributes of a default category.
    ///
    ///Sends a `GET` request to `/categories/{category_guid}`
    ///
    ///Arguments:
    /// - `category_guid`: The unique id for a `category`.
    pub async fn read_default_category<'a>(
        &'a self,
        category_guid: &'a str,
    ) -> Result<ResponseValue<types::CategoryResponseBody>, Error<()>> {
        let url = format!(
            "{}/categories/{}",
            self.baseurl,
            encode_path(&category_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_default_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List institutions
    ///
    ///This endpoint returns a list of institutions based on the specified
    /// search term or parameter.
    ///
    ///Sends a `GET` request to `/institutions`
    ///
    ///Arguments:
    /// - `iso_country_code`: An array of strings that filters institutions in
    ///   the widget by the specified country code. Acceptable codes include
    ///   `US`, `CA`, and `MX` (Mexico).
    /// - `name`: This will list only institutions in which the appended string
    ///   appears.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    /// - `supports_account_identification`: Filter only institutions which
    ///   support account identification.
    /// - `supports_account_statement`: Filter only institutions which support
    ///   account statements.
    /// - `supports_account_verification`: Filter only institutions which
    ///   support account verification.
    /// - `supports_transaction_history`: Filter only institutions which support
    ///   extended transaction history.
    pub async fn list_institutions<'a>(
        &'a self,
        iso_country_code: Option<&'a ::std::vec::Vec<::std::string::String>>,
        name: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        supports_account_identification: Option<bool>,
        supports_account_statement: Option<bool>,
        supports_account_verification: Option<bool>,
        supports_transaction_history: Option<bool>,
    ) -> Result<ResponseValue<types::InstitutionsResponseBody>, Error<()>> {
        let url = format!("{}/institutions", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "iso_country_code",
                &iso_country_code,
            ))
            .query(&progenitor_client::QueryParam::new("name", &name))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new(
                "supports_account_identification",
                &supports_account_identification,
            ))
            .query(&progenitor_client::QueryParam::new(
                "supports_account_statement",
                &supports_account_statement,
            ))
            .query(&progenitor_client::QueryParam::new(
                "supports_account_verification",
                &supports_account_verification,
            ))
            .query(&progenitor_client::QueryParam::new(
                "supports_transaction_history",
                &supports_transaction_history,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_institutions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List favorite institutions
    ///
    ///This endpoint returns a paginated list containing institutions that have
    /// been set as the partners favorites, sorted by popularity. Please
    /// contact MX to set a list of favorites.
    ///
    ///Sends a `GET` request to `/institutions/favorites`
    ///
    ///Arguments:
    /// - `iso_country_code`: An array of strings that filters institutions in
    ///   the widget by the specified country code. Acceptable codes include
    ///   `US`, `CA`, and `MX` (Mexico).
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_favorite_institutions<'a>(
        &'a self,
        iso_country_code: Option<&'a ::std::vec::Vec<::std::string::String>>,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InstitutionsResponseBody>, Error<()>> {
        let url = format!("{}/institutions/favorites", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "iso_country_code",
                &iso_country_code,
            ))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_favorite_institutions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read institution
    ///
    ///This endpoint returns information about the institution specified by
    /// `institution_code`.
    ///
    ///Sends a `GET` request to `/institutions/{institution_code}`
    ///
    ///Arguments:
    /// - `institution_code`: The institution_code of the institution.
    pub async fn read_institution<'a>(
        &'a self,
        institution_code: &'a str,
    ) -> Result<ResponseValue<types::InstitutionResponseBody>, Error<()>> {
        let url = format!(
            "{}/institutions/{}",
            self.baseurl,
            encode_path(&institution_code.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_institution",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List institution credentials
    ///
    ///Use this endpoint to see which credentials will be needed to create a
    /// member for a specific institution.
    ///
    ///Passing an invalid `institution_code` returns a `404`.
    ///
    ///
    ///Sends a `GET` request to `/institutions/{institution_code}/credentials`
    ///
    ///Arguments:
    /// - `institution_code`: The institution_code of the institution.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_institution_credentials<'a>(
        &'a self,
        institution_code: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::CredentialsResponseBody>, Error<()>> {
        let url = format!(
            "{}/institutions/{}/credentials",
            self.baseurl,
            encode_path(&institution_code.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_institution_credentials",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List managed institutions
    ///
    ///This endpoint returns a list of institutions which can be used to create
    /// partner-managed members.
    ///
    ///Sends a `GET` request to `/managed_institutions`
    ///
    ///Arguments:
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_managed_institutions<'a>(
        &'a self,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InstitutionsResponseBody>, Error<()>> {
        let url = format!("{}/managed_institutions", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_managed_institutions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read merchant location
    ///
    ///This endpoint returns the specified `merchant_location` resource. The
    /// `merchant_location_guid` can be found on `transaction` objects.
    ///
    ///Sends a `GET` request to `/merchant_locations/{merchant_location_guid}`
    ///
    ///Arguments:
    /// - `merchant_location_guid`: The unique id for a `merchant_location`.
    pub async fn read_merchant_location<'a>(
        &'a self,
        merchant_location_guid: &'a str,
    ) -> Result<ResponseValue<types::MerchantLocationResponseBody>, Error<()>> {
        let url = format!(
            "{}/merchant_locations/{}",
            self.baseurl,
            encode_path(&merchant_location_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_merchant_location",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List merchants
    ///
    ///This endpoint returns a paginated list of all the merchants in the MX
    /// system.
    ///
    ///Sends a `GET` request to `/merchants`
    ///
    ///Arguments:
    /// - `name`: This will list only merchants in which the appended string
    ///   appears.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_merchants<'a>(
        &'a self,
        name: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::MerchantsResponseBody>, Error<()>> {
        let url = format!("{}/merchants", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("name", &name))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_merchants",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read merchant
    ///
    ///Returns information about a particular merchant, such as a logo, name,
    /// and website.
    ///
    ///Sends a `GET` request to `/merchants/{merchant_guid}`
    ///
    ///Arguments:
    /// - `merchant_guid`: The unique id for a `merchant`.
    pub async fn read_merchant<'a>(
        &'a self,
        merchant_guid: &'a str,
    ) -> Result<ResponseValue<types::MerchantResponseBody>, Error<()>> {
        let url = format!(
            "{}/merchants/{}",
            self.baseurl,
            encode_path(&merchant_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_merchant",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///(Deprecated) Request an authorization code
    ///
    ///(This endpoint is deprecated. Clients should use `/authorization_code`.)
    /// Clients use this endpoint to request an authorization_code according to
    /// a user, member, and account specified in the request body. Clients then
    /// pass this code to processors. Processor access is scoped only to the
    /// user/member/account specified in this request. Before requesting an
    /// authorization_code, clients must have verified the specified member.
    ///
    ///Sends a `POST` request to `/payment_processor_authorization_code`
    ///
    ///Arguments:
    /// - `body`: The scope for the authorization code.
    pub async fn deprecated_request_payment_processor_authorization_code<'a>(
        &'a self,
        body: &'a types::PaymentProcessorAuthorizationCodeRequestBody,
    ) -> Result<ResponseValue<types::PaymentProcessorAuthorizationCodeResponseBody>, Error<()>>
    {
        let url = format!("{}/payment_processor_authorization_code", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "deprecated_request_payment_processor_authorization_code",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Enhance transactions
    ///
    ///Use this endpoint to categorize, cleanse, and classify transactions.
    /// These transactions are not persisted or stored on the MX platform. <br
    /// /><br />For more information on returned data, please see the [Enhanced
    /// Transactions fields
    /// guide](/api-reference/platform-api/reference/transactions-overview#
    /// enhanced-transactions).
    ///
    ///Sends a `POST` request to `/transactions/enhance`
    ///
    ///Arguments:
    /// - `body`: Transaction object to be enhanced
    pub async fn enhance_transactions<'a>(
        &'a self,
        body: &'a types::EnhanceTransactionsRequestBody,
    ) -> Result<ResponseValue<types::EnhanceTransactionsResponseBody>, Error<()>> {
        let url = format!("{}/transactions/enhance", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "enhance_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List users
    ///
    ///Use this endpoint to list every user you've created in the MX Platform
    /// API.
    ///
    ///Sends a `GET` request to `/users`
    ///
    ///Arguments:
    /// - `email`: The user `email` to search for.
    /// - `id`: The user `id` to search for.
    /// - `is_disabled`: Search for users that are diabled.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_users<'a>(
        &'a self,
        email: Option<&'a str>,
        id: Option<&'a str>,
        is_disabled: Option<bool>,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::UsersResponseBody>, Error<()>> {
        let url = format!("{}/users", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("email", &email))
            .query(&progenitor_client::QueryParam::new("id", &id))
            .query(&progenitor_client::QueryParam::new(
                "is_disabled",
                &is_disabled,
            ))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_users",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create user
    ///
    ///Use this endpoint to create a new user. The API will respond with the
    /// newly-created user object if successful, containing a `guid` that you'll
    /// set as the `user_guid` in other requests when required. Disabling a user
    /// means that accounts and transactions associated with it will not be
    /// updated in the background by MX. It will also restrict access to that
    /// users data until they are no longer disabled.
    ///
    ///Sends a `POST` request to `/users`
    ///
    ///Arguments:
    /// - `body`: User object to be created. (None of these parameters are
    ///   required, but the user object cannot be empty)
    pub async fn create_user<'a>(
        &'a self,
        body: &'a types::UserCreateRequestBody,
    ) -> Result<ResponseValue<types::UserResponseBody>, Error<()>> {
        let url = format!("{}/users", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read user
    ///
    ///Use this endpoint to read the attributes of a specific user.
    ///
    ///Sends a `GET` request to `/users/{user_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn read_user<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::UserResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update user
    ///
    ///Use this endpoint to update the attributes of the specified user.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: User object to be updated (None of these parameters are
    ///   required, but the user object cannot be empty.)
    pub async fn update_user<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::UserUpdateRequestBody,
    ) -> Result<ResponseValue<types::UserResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete user
    ///
    ///Use this endpoint to delete the specified `user`. The response will have
    /// a status of `204 No Content` without an object.
    ///
    ///:::warning
    ///Deleting a user is permanent. Deleted users can never be restored. For more info, see [Deleting Objects](https://docs.mx.com/api-reference/platform-api/overview/deleting-objects).
    ///:::
    ///
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `accept`: Specifies the media type expected in the response.
    pub async fn delete_user<'a>(
        &'a self,
        user_guid: &'a str,
        accept: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        header_map.append("Accept", accept.to_string().try_into()?);
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List accounts
    ///
    ///This endpoint returns a list of all the accounts associated with the
    /// specified `user`.
    ///
    ///:::warning
    ///This request will not return the full account number. It may return the last four digits of the account number if that information has been provided during aggregation. If you need the full account number, please refer to [List account numbers by member](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-member/), [List account numbers by account](https://docs.mx.com/api-reference/platform-api/reference/list-account-numbers-by-account/), or the [Fetch Account and Routing Numbers](https://docs.mx.com/products/connectivity/instant-account-verification/fetch-account-routing-number-api/#4-read-the-account-numbers) guide.
    ///:::
    ///
    ///
    ///Sends a `GET` request to `/users/{user_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `is_manual`: List only accounts that were manually created.
    /// - `member_is_managed_by_user`: List only accounts whose member is
    ///   managed by the user.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `use_case`: The use case associated with the member. Valid values are
    ///   `PFM` and `MONEY_MOVEMENT`. For example, you can append either
    ///   `?use_case=PFM` or `?use_case=MONEY_MOVEMENT`.
    pub async fn list_user_accounts<'a>(
        &'a self,
        user_guid: &'a str,
        is_manual: Option<bool>,
        member_is_managed_by_user: Option<bool>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        use_case: Option<&'a str>,
    ) -> Result<ResponseValue<types::AccountsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("is_manual", &is_manual))
            .query(&progenitor_client::QueryParam::new(
                "member_is_managed_by_user",
                &member_is_managed_by_user,
            ))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new("use_case", &use_case))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_user_accounts",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create manual account
    ///
    ///This endpoint can only be used to create manual accounts. Creating a
    /// manual account will automatically create it under the Manual Institution
    /// member. Since a manual account has no credentials tied to the member,
    /// the account will never aggregate or include data from a data feed..
    ///
    ///Sends a `POST` request to `/users/{user_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: Manual account object to be created.
    pub async fn create_manual_account<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::AccountCreateRequestBody,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_manual_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read account
    ///
    ///This endpoint returns the specified `account` resource.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/accounts/{account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    pub async fn read_account<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete manual account
    ///
    ///This endpoint deletes accounts that were manually created. The API will
    /// respond with an empty object and a status of `204 No Content`.
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}/accounts/{account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `accept`: Specifies the media type expected in the response.
    pub async fn delete_manual_account<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        accept: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        header_map.append("Accept", accept.to_string().try_into()?);
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_manual_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List account numbers by account
    ///
    ///This endpoint returns a list of account numbers associated with the
    /// specified `account`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/accounts/{account_guid}/account_numbers`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_account_numbers_by_account<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::AccountNumbersResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}/account_numbers",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_account_numbers_by_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List insights by account
    ///
    ///Use this endpoint to list all insights associated with an account GUID.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/accounts/{account_guid}/insights`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_insights_by_account<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InsightsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}/insights",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_insights_by_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List transactions by account
    ///
    ///Requests to this endpoint return a list of transactions associated with
    /// the specified account. <br /><br />Enhanced transaction data may be
    /// requested using the `includes` parameter. To use this optional
    /// parameter, the value should include the optional metadata requested such
    /// as `repeating_transactions`, `merchants`, `classifications`,
    /// `geolocations`. For more information, see the [Optional Enhancement
    /// Query Parameter
    /// guide](/api-reference/platform-api/reference/transactions-overview#
    /// enhanced-transactions#optional-enhancement-query-parameter).
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/accounts/{account_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `category_guid`: Filter transactions belonging to specified
    ///   `category_guid`.
    ///
    ///For example, `?category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `category_guid`: Filter transactions belonging to any specified
    ///   `category_guid[]` in url.
    ///
    ///For example,
    /// `?category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `from_created_at`: Filter transactions from the date the transaction
    ///   was created. This only supports ISO 8601 format without timestamp
    ///   (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `from_date`: Filter transactions from this date. This only supports
    ///   ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days
    ///   ago if not provided.
    /// - `from_updated_at`: Filter transactions from the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `includes`: Options for enhanced transactions. This query parameter is
    ///   optional. Possible additional metadata: `repeating_transactions`,
    ///   `merchants`, `classifications`, `geolocations`. The query value is
    ///   format sensitive. To retrieve all available enhancements, append:
    ///
    ///`?includes=repeating_transactions,merchants,classifications,
    /// geolocations`.
    ///
    ///The query options may be combined to specific enhancements. For example,
    /// to request Repeating Transactions and Geolocation data, use:
    ///
    ///`?includes=repeating_transactions,geolocations`.
    ///
    /// - Repeating Transactions: Identifies transactions with predictable
    ///   recurrence patterns (e.g., Bill, Income, Subscription).
    /// - Merchants: Enriches transactions with merchant name.
    /// - Classifications: Provides more insight into the type of money movement
    ///   that is occurring on the transaction, whether it be retail or
    ///   investments.
    /// - Geolocation: Provides geographic metadata.
    ///
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `to_created_at`: Filter transaction to the date in which the
    ///   transaction was created. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `to_date`: Filter transactions to this date (at midnight). This only
    ///   supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5
    ///   days forward from the day the request is made to capture pending
    ///   transactions.
    /// - `to_updated_at`: Filter transactions to the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `top_level_category_guid`: Filter transactions belonging to specified
    ///   `top_level_category_guid`. This must be top level category guid, use
    ///   `category_guid` for subcategory guid.
    ///
    ///For example,
    /// `?top_level_category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `top_level_category_guid`: Filter transactions belonging to any
    ///   specified `top_level_category_guid[]` in url. This must be top level
    ///   category guid(s), use `category_guid` for subcategory guid(s).
    ///
    ///For example,
    /// `?top_level_category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    pub async fn list_transactions_by_account<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        category_guid: Option<&'a str>,
        from_created_at: Option<&'a str>,
        from_date: Option<&'a str>,
        from_updated_at: Option<&'a str>,
        includes: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        to_created_at: Option<&'a str>,
        to_date: Option<&'a str>,
        to_updated_at: Option<&'a str>,
        top_level_category_guid: Option<&'a str>,
    ) -> Result<ResponseValue<types::TransactionsResponseBodyIncludes>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "category_guid",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "category_guid[]",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "from_created_at",
                &from_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("from_date", &from_date))
            .query(&progenitor_client::QueryParam::new(
                "from_updated_at",
                &from_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new("includes", &includes))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new(
                "to_created_at",
                &to_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("to_date", &to_date))
            .query(&progenitor_client::QueryParam::new(
                "to_updated_at",
                &to_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid",
                &top_level_category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid[]",
                &top_level_category_guid,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_transactions_by_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create manual transaction
    ///
    ///This endpoint can only be used to create manual transactions that are
    /// under a manual account. This endpoint accepts the optional
    /// MX-Skip-Webhook header and skip_webhook parameter.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/accounts/{account_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `body`
    pub async fn create_manual_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        body: &'a types::TransactionCreateRequestBody,
    ) -> Result<ResponseValue<types::TransactionCreateResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_manual_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List categories
    ///
    ///Use this endpoint to list all categories associated with a `user`,
    /// including both default and custom categories.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/categories`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_categories<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::CategoriesResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/categories",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_categories",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create category
    ///
    ///Use this endpoint to create a new custom category for a specific `user`.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/categories`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: Custom category object to be created
    pub async fn create_category<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::CategoryCreateRequestBody,
    ) -> Result<ResponseValue<types::CategoryResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/categories",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List default categories by user
    ///
    ///Use this endpoint to retrieve a list of all the default categories and
    /// subcategories, scoped by user, offered within the MX Platform API. In
    /// other words, each item in the returned list will have its `is_default`
    /// field set to `true`. There are currently 119 default categories and
    /// subcategories. Both the _list default categories_ and _list default
    /// categories by user_ endpoints return the same results. The different
    /// routes are provided for convenience.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/categories/default`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_default_categories_by_user<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::CategoriesResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/categories/default",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_default_categories_by_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a custom category
    ///
    ///Use this endpoint to read the attributes of either a default category or
    /// a custom category.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/categories/{category_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `category_guid`: The unique id for a `category`.
    pub async fn read_category<'a>(
        &'a self,
        user_guid: &'a str,
        category_guid: &'a str,
    ) -> Result<ResponseValue<types::CategoryResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/categories/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&category_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update category
    ///
    ///Use this endpoint to update the attributes of a custom category
    /// according to its unique GUID.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/categories/{category_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `category_guid`: The unique id for a `category`.
    /// - `body`: Category object to be updated (While no single parameter is
    ///   required, the `category` object cannot be empty)
    pub async fn update_category<'a>(
        &'a self,
        user_guid: &'a str,
        category_guid: &'a str,
        body: &'a types::CategoryUpdateRequestBody,
    ) -> Result<ResponseValue<types::CategoryResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/categories/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&category_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete category
    ///
    ///Use this endpoint to delete a specific custom category according to its
    /// unique GUID. The API will respond with an empty object and a status of
    /// `204 No Content`.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/categories/{category_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `category_guid`: The unique id for a `category`.
    pub async fn delete_category<'a>(
        &'a self,
        user_guid: &'a str,
        category_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/categories/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&category_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_category",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///(Deprecated) Request connect widget URL
    ///
    ///This endpoint will return a URL for an embeddable version of MX Connect.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/connect_widget_url`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: Optional config options for WebView (is_mobile_webview,
    ///   current_institution_code, current_member_guid, update_credentials)
    pub async fn request_connect_widget_url<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::ConnectWidgetRequestBody,
    ) -> Result<ResponseValue<types::ConnectWidgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/connect_widget_url",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "request_connect_widget_url",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all insights for a user
    ///
    ///Use this endpoint to list all the insights associated with the user.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/insights`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_insights_user<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InsightsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_insights_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all categories associated with an insight
    ///
    ///Use this endpoint to list all the categories associated with the
    /// insight.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/insights/{insight_guid}/categories`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_categories_insight<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::CategoriesResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}/categories",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_categories_insight",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all accounts associated with an insight
    ///
    ///Use this endpoint to list all the accounts associated with the insight.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/insights/{insight_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_accounts_insight<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::AccountsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_accounts_insight",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all merchants associated with an insight
    ///
    ///Use this endpoint to list all the merchants associated with the insight.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/insights/{insight_guid}/merchants`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_merchants_insight<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::MerchantsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}/merchants",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_merchants_insight",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all scheduled payments associated with an insight
    ///
    ///Use this endpoint to list all the scheduled payments associated with the
    /// insight.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/insights/{insight_guid}/scheduled_payments`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_scheduled_payments_insight<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::ScheduledPaymentsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}/scheduled_payments",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_scheduled_payments_insight",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all transactions associated with an insight
    ///
    ///Use this endpoint to list all the transactions associated with the
    /// insight.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/insights/{insight_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_transactions_insight<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::TransactionsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_transactions_insight",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read insight
    ///
    ///Use this endpoint to read the attributes of an insight according to its
    /// unique GUID.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/insights/{insight_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    pub async fn read_insight_user<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
    ) -> Result<ResponseValue<types::InsightResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_insight_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update insight
    ///
    ///Use this endpoint to update the attributes of an insight according to
    /// its unique GUID.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/insights/{insight_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `insight_guid`: The unique identifier for the insight. Defined by MX.
    /// - `body`: The insight to be updated (None of these parameters are
    ///   required, but the user object cannot be empty.)
    pub async fn update_insight<'a>(
        &'a self,
        user_guid: &'a str,
        insight_guid: &'a str,
        body: &'a types::InsightUpdateRequestBody,
    ) -> Result<ResponseValue<types::InsightResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/insights/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&insight_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_insight",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List managed members
    ///
    ///This endpoint returns a list of all the partner-managed members
    /// associated with the specified `user`.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/managed_members`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_managed_members<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::MembersResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_managed_members",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create managed member
    ///
    ///Use this endpoint to create a new partner-managed `member`.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/managed_members`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: Managed member to be created.
    pub async fn create_managed_member<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::ManagedMemberCreateRequestBody,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_managed_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read managed member
    ///
    ///This endpoint returns the attributes of the specified
    /// partner-managed`member`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/managed_members/{member_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn read_managed_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_managed_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update managed member
    ///
    ///Use this endpoint to update the attributes of the specified
    /// partner_managed `member`.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/managed_members/{member_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `body`: Managed member object to be updated (While no single parameter
    ///   is required, the request body can't be empty)
    pub async fn update_managed_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        body: &'a types::ManagedMemberUpdateRequestBody,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_managed_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete managed member
    ///
    ///Use this endpoint to delete the specified partner-managed `member`. The
    /// endpoint will respond with a status of `204 No Content` without a
    /// resource.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/managed_members/{member_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `accept`: Specifies the media type expected in the response.
    pub async fn delete_managed_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        accept: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        header_map.append("Accept", accept.to_string().try_into()?);
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_managed_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List managed accounts
    ///
    ///Use this endpoint to retrieve a list of all the partner-managed accounts
    /// associated with the given partner-managed member.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_managed_accounts<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::AccountsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_managed_accounts",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create managed account
    ///
    ///Use this endpoint to create a partner-managed account.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `body`: Managed account to be created.
    pub async fn create_managed_account<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        body: &'a types::ManagedAccountCreateRequestBody,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_managed_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read managed account
    ///
    ///Use this endpoint to read the attributes of a partner-managed account
    /// according to its unique guid.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    pub async fn read_managed_account<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_managed_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update managed account
    ///
    ///Use this endpoint to update the attributes of a partner-managed account
    /// according to its unique GUID.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `body`: Managed account object to be updated (While no single
    ///   parameter is required, the request body can't be empty)
    pub async fn update_managed_account<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        body: &'a types::ManagedAccountUpdateRequestBody,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_managed_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete managed account
    ///
    ///Use this endpoint to delete a partner-managed account according to its
    /// unique GUID. If successful, the API will respond with a status of `204
    /// No Content`.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    pub async fn delete_managed_account<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_managed_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List managed transactions
    ///
    ///This endpoint returns a list of all the partner-managed transactions
    /// associated with the specified `account`, scoped through a `user` and a
    /// `member`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `from_date`: Filter transactions from this date. This only supports
    ///   ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days
    ///   ago if not provided.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `to_date`: Filter transactions to this date (at midnight). This only
    ///   supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5
    ///   days forward from the day the request is made to capture pending
    ///   transactions.
    pub async fn list_managed_transactions<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        from_date: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        to_date: Option<&'a str>,
    ) -> Result<ResponseValue<types::TransactionsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from_date", &from_date))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new("to_date", &to_date))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_managed_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create managed transaction
    ///
    ///Use this endpoint to create a new partner-managed `transaction`.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `body`: Managed transaction to be created.
    pub async fn create_managed_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        body: &'a types::ManagedTransactionCreateRequestBody,
    ) -> Result<ResponseValue<types::TransactionResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_managed_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read managed transaction
    ///
    ///Requests to this endpoint will return the attributes of the specified
    /// partner-managed `transaction`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}/transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    pub async fn read_managed_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        transaction_guid: &'a str,
    ) -> Result<ResponseValue<types::TransactionResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_managed_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update managed transaction
    ///
    ///Use this endpoint to update the attributes of the specified
    /// partner_managed `transaction`.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}/transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    /// - `body`: Managed transaction object to be updated (While no single
    ///   parameter is required, the request body can't be empty)
    pub async fn update_managed_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        transaction_guid: &'a str,
        body: &'a types::ManagedTransactionUpdateRequestBody,
    ) -> Result<ResponseValue<types::TransactionResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_managed_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete managed transaction
    ///
    ///Use this endpoint to delete the specified partner-managed `transaction`.
    /// The endpoint will respond with a status of `204 No Content` without a
    /// resource.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/managed_members/{member_guid}/accounts/
    /// {account_guid}/transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    pub async fn delete_managed_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        transaction_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/managed_members/{}/accounts/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_managed_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List members
    ///
    ///This endpoint returns an array which contains information on every
    /// member associated with a specific user.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/members`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `use_case`: The use case associated with the member. Valid values are
    ///   `PFM` and `MONEY_MOVEMENT`. For example, you can append either
    ///   `?use_case=PFM` or `?use_case=MONEY_MOVEMENT`.
    pub async fn list_members<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
        use_case: Option<&'a str>,
    ) -> Result<ResponseValue<types::MembersResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new("use_case", &use_case))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_members",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create member
    ///
    ///This endpoint allows you to create a new member. Members are created
    /// with the required parameters credentials and institution_code, and the
    /// optional parameters id and metadata. When creating a member, youll need
    /// to include the correct type of credential required by the financial
    /// institution and provided by the user. You can find out which credential
    /// type is required with the `/institutions/{institution_code}/credentials`
    /// endpoint. If successful, the MX Platform API will respond with the
    /// newly-created member object. Once you successfully create a member, MX
    /// will immediately validate the provided credentials and attempt to
    /// aggregate data for accounts and transactions.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/members`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `x_callback_payload`: The base64 encoded string defined in this header
    ///   will be returned in the [Member](/resources/webhooks/member/) and
    ///   [Member Data Updated](/resources/webhooks/member#member-data-updated)
    ///   webhooks. This allows you to trace user interactions and workflows
    ///   initiated externally and internally in the MX Platform. Max 1024
    ///   characters.
    /// - `body`: Member object to be created with optional parameters (id and
    ///   metadata) and required parameters (credentials and institution_code)
    pub async fn create_member<'a>(
        &'a self,
        user_guid: &'a str,
        x_callback_payload: Option<&'a str>,
        body: &'a types::MemberCreateRequestBody,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = x_callback_payload {
            header_map.append("X-CALLBACK-PAYLOAD", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read member
    ///
    ///Use this endpoint to read the attributes of a specific member.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/members/{member_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn read_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update member
    ///
    ///Use this endpoint to update a members attributes. Only the credentials,
    /// id, and metadata parameters can be updated. To get a list of the
    /// required credentials for the member, use the list member credentials
    /// endpoint.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/members/{member_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `x_callback_payload`: The base64 encoded string defined in this header
    ///   will be returned in the [Member](/resources/webhooks/member/) and
    ///   [Member Data Updated](/resources/webhooks/member#member-data-updated)
    ///   webhooks. This allows you to trace user interactions and workflows
    ///   initiated externally and internally in the MX Platform. Max 1024
    ///   characters.
    /// - `body`: Member object to be updated (While no single parameter is
    ///   required, the request body can't be empty)
    pub async fn update_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        x_callback_payload: Option<&'a str>,
        body: &'a types::MemberUpdateRequestBody,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = x_callback_payload {
            header_map.append("X-CALLBACK-PAYLOAD", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete member
    ///
    ///Accessing this endpoint will permanently delete a member.
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}/members/{member_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn delete_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List account numbers by member
    ///
    ///This endpoint returns a list of account numbers associated with the
    /// specified `member`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/account_numbers`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_account_numbers_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::AccountNumbersResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/account_numbers",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_account_numbers_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List account owners by member
    ///
    ///This endpoint returns an array with information about every account
    /// associated with a particular member.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/account_owners`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_account_owners_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::AccountOwnersResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/account_owners",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_account_owners_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List accounts by member
    ///
    ///This endpoint returns a list of all the accounts associated with the
    /// specified `member`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `member_is_managed_by_user`: List only accounts whose member is
    ///   managed by the user.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_member_accounts<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        member_is_managed_by_user: Option<bool>,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::AccountsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "member_is_managed_by_user",
                &member_is_managed_by_user,
            ))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_member_accounts",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read account by member
    ///
    ///This endpoint allows you to read the attributes of an `account`
    /// resource.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/accounts/{account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    pub async fn read_account_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_account_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update account by member
    ///
    ///This endpoint allows you to update certain attributes of an `account`
    /// resource, including manual accounts. For manual accounts, you can update
    /// every field listed. For aggregated accounts, you can only update
    /// `is_business`, `is_hidden` and `metadata`.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/members/{member_guid}/accounts/{account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `body`
    pub async fn update_account_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        body: &'a types::AccountUpdateRequestBody,
    ) -> Result<ResponseValue<types::AccountResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_account_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update Transaction by Account
    ///
    ///Use this endpoint to update a specific transaction according to its
    /// unique GUID.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/members/{member_guid}/accounts/{account_guid}/
    /// transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    /// - `body`: Transaction object to be updated
    pub async fn update_transaction_by_account<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        account_guid: &'a str,
        transaction_guid: &'a str,
        body: &'a types::TransactionUpdateRequestBody,
    ) -> Result<ResponseValue<types::TransactionResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/accounts/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&account_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_transaction_by_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Aggregate member
    ///
    ///Calling this endpoint initiates an aggregation event for the member.
    /// This brings in the latest account and transaction data from the
    /// connected institution. If this data has recently been updated, MX may
    /// not initiate an aggregation event.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/aggregate`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `include_holdings`: When set to `false`, the aggregation will not
    ///   gather holdings data. Defaults to `true`.
    /// - `include_transactions`: When set to `false`, the aggregation will not
    ///   gather transactions data. Defaults to `true`.
    /// - `x_callback_payload`: The base64 encoded string defined in this header
    ///   will be returned in the [Member](/resources/webhooks/member/) and
    ///   [Member Data Updated](/resources/webhooks/member#member-data-updated)
    ///   webhooks. This allows you to trace user interactions and workflows
    ///   initiated externally and internally in the MX Platform. Max 1024
    ///   characters.
    pub async fn aggregate_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        include_holdings: Option<bool>,
        include_transactions: Option<bool>,
        x_callback_payload: Option<&'a str>,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/aggregate",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = x_callback_payload {
            header_map.append("X-CALLBACK-PAYLOAD", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "include_holdings",
                &include_holdings,
            ))
            .query(&progenitor_client::QueryParam::new(
                "include_transactions",
                &include_transactions,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "aggregate_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List member challenges
    ///
    ///Use this endpoint for information on what multi-factor authentication
    /// challenges need to be answered in order to aggregate a member. If the
    /// aggregation is not challenged, i.e., the member does not have a
    /// connection status of `CHALLENGED`, then code `204 No Content` will be
    /// returned. If the aggregation has been challenged, i.e., the member does
    /// have a connection status of `CHALLENGED`, then code `200 OK` will be
    /// returned - along with the corresponding credentials.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/challenges`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_member_challenges<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::ChallengesResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/challenges",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_member_challenges",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Check balances
    ///
    ///This endpoint operates much like the aggregate member endpoint except
    /// that it gathers only account balance information; it does not gather any
    /// transaction data.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/check_balance`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn check_balances<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/check_balance",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "check_balances",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List member credentials
    ///
    ///This endpoint returns an array which contains information on every
    /// non-MFA credential associated with a specific member.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/credentials`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_member_credentials<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::CredentialsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/credentials",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_member_credentials",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Extend history
    ///
    ///Some institutions allow developers to access an extended transaction
    /// history with up to 24 months of data associated with a particular
    /// member. The process for fetching and then reading this extended
    /// transaction history is much like standard aggregation, and it may
    /// trigger multi-factor authentication.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/extend_history`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn extend_history<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/extend_history",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "extend_history",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Fetch statements
    ///
    ///Use this endpoint to fetch the statements associated with a particular
    /// member.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/fetch_statements`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn fetch_statements<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/fetch_statements",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "fetch_statements",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List holdings by member
    ///
    ///This endpoint lists all holdings associated with the specified member.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/investment_holdings`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_holdings_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InvestmentHoldingsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/investment_holdings",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_holdings_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List holdings by user
    ///
    ///This endpoint lists all holdings associated with the user across all
    /// accounts.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/investment_holdings`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_holdings<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InvestmentHoldingsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/investment_holdings",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_holdings",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read holding
    ///
    ///Use this endpoint to read the attributes of a specific `holding`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/investment_holdings/{holding_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `holding_guid`: The unique id for a `holding`.
    pub async fn read_holding<'a>(
        &'a self,
        user_guid: &'a str,
        holding_guid: &'a str,
    ) -> Result<ResponseValue<types::InvestmentHoldingResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/investment_holdings/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&holding_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_holding",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List holdings by account
    ///
    ///This endpoint lists all holdings associated with the particular account
    /// defined.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/accounts/{account_guid}/investment_holdings`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_holdings_by_account<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InvestmentHoldingsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/accounts/{}/investment_holdings",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_holdings_by_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Deactivate user from Investment Holdings
    ///
    ///This endpoint deactivates the specific user from the
    /// `/investment_holdings` product. To reactivate a user, use any of the
    /// current `/investment_holding` endpoints.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/investment_holdings_deactivate`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn deactivate_user<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::InvestmentHoldingsDeactivation>, Error<()>> {
        let url = format!(
            "{}/users/{}/investment_holdings_deactivate",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "deactivate_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Identify member
    ///
    ///The identify endpoint begins an identification process for an
    /// already-existing member.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/identify`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn identify_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/identify",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "identify_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Request oauth window uri
    ///
    ///This endpoint will generate an `oauth_window_uri` for the specified
    /// `member`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/oauth_window_uri`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `client_redirect_url`: A URL that MX will redirect to at the end of
    ///   OAuth with additional query parameters. Only available with
    ///   `referral_source=APP`.
    /// - `enable_app2app`: This indicates whether OAuth app2app behavior is
    ///   enabled for institutions that support it. Defaults to `true`. When set
    ///   to `false`, any `oauth_window_uri` generated will **not** direct the
    ///   end user to the institution's mobile application. This setting is not
    ///   persistent. This setting currently only affects Chase institutions.
    /// - `referral_source`: Must be either `BROWSER` or `APP` depending on the
    ///   implementation. Defaults to `BROWSER`.
    /// - `skip_aggregation`: Setting this parameter to `true` will prevent the
    ///   member from automatically aggregating after being redirected from the
    ///   authorization page.
    /// - `ui_message_webview_url_scheme`: A scheme for routing the user back to
    ///   the application state they were previously in. Only available with
    ///   `referral_source=APP`.
    pub async fn request_o_auth_window_uri<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        client_redirect_url: Option<&'a str>,
        enable_app2app: Option<&'a str>,
        referral_source: Option<&'a str>,
        skip_aggregation: Option<bool>,
        ui_message_webview_url_scheme: Option<&'a str>,
    ) -> Result<ResponseValue<types::OAuthWindowResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/oauth_window_uri",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "client_redirect_url",
                &client_redirect_url,
            ))
            .query(&progenitor_client::QueryParam::new(
                "enable_app2app",
                &enable_app2app,
            ))
            .query(&progenitor_client::QueryParam::new(
                "referral_source",
                &referral_source,
            ))
            .query(&progenitor_client::QueryParam::new(
                "skip_aggregation",
                &skip_aggregation,
            ))
            .query(&progenitor_client::QueryParam::new(
                "ui_message_webview_url_scheme",
                &ui_message_webview_url_scheme,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "request_o_auth_window_uri",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Resume aggregation
    ///
    ///This endpoint answers the challenges needed when a member has been
    /// challenged by multi-factor authentication.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/members/{member_guid}/resume`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `body`: Member object with MFA challenge answers
    pub async fn resume_aggregation<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        body: &'a types::MemberResumeRequestBody,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/resume",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "resume_aggregation",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List statements by member
    ///
    ///Use this endpoint to get an array of available statements.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/statements`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_statements_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::StatementsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/statements",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_statements_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read statement by member
    ///
    ///Use this endpoint to read a JSON representation of the statement.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/statements/{statement_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `statement_guid`: The unique id for a `statement`.
    pub async fn read_statement_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        statement_guid: &'a str,
    ) -> Result<ResponseValue<types::StatementResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/statements/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&statement_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_statement_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Download statement pdf
    ///
    ///Use this endpoint to download a specified statement PDF.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/statements/{statement_guid}.
    /// pdf`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `statement_guid`: The unique id for a `statement`.
    pub async fn download_statement_pdf<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        statement_guid: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/statements/{}.pdf",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&statement_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "download_statement_pdf",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read member status
    ///
    ///This endpoint provides the status of the members most recent aggregation
    /// event. This is an important step in the aggregation process, and the
    /// results returned by this endpoint should determine what you do next in
    /// order to successfully aggregate a member. MX has introduced new, more
    /// detailed information on the current status of a members connection to a
    /// financial institution and the state of its aggregation - the
    /// connection_status field. These are intended to replace and expand upon
    /// the information provided in the status field, which will soon be
    /// deprecated; support for the status field remains for the time being.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/status`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn read_member_status<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberStatusResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/status",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_member_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List transactions by member
    ///
    ///Requests to this endpoint return a list of transactions associated with
    /// the specified `member`, across all accounts associated with that
    /// `member`. <br /><br />Enhanced transaction data may be requested using
    /// the `includes` parameter. To use this optional parameter, the value
    /// should include the optional metadata requested such as
    /// `repeating_transactions`, `merchants`, `classifications`,
    /// `geolocations`. For more information, see the [Optional Enhancement
    /// Query Parameter
    /// guide](/api-reference/platform-api/reference/transactions-overview#
    /// enhanced-transactions#optional-enhancement-query-parameter).
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `category_guid`: Filter transactions belonging to specified
    ///   `category_guid`.
    ///
    ///For example, `?category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `category_guid`: Filter transactions belonging to any specified
    ///   `category_guid[]` in url.
    ///
    ///For example,
    /// `?category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `from_created_at`: Filter transactions from the date the transaction
    ///   was created. This only supports ISO 8601 format without timestamp
    ///   (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `from_date`: Filter transactions from this date. This only supports
    ///   ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days
    ///   ago if not provided.
    /// - `from_updated_at`: Filter transactions from the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `includes`: Options for enhanced transactions. This query parameter is
    ///   optional. Possible additional metadata: `repeating_transactions`,
    ///   `merchants`, `classifications`, `geolocations`. The query value is
    ///   format sensitive. To retrieve all available enhancements, append:
    ///
    ///`?includes=repeating_transactions,merchants,classifications,
    /// geolocations`.
    ///
    ///The query options may be combined to specific enhancements. For example,
    /// to request Repeating Transactions and Geolocation data, use:
    ///
    ///`?includes=repeating_transactions,geolocations`.
    ///
    /// - Repeating Transactions: Identifies transactions with predictable
    ///   recurrence patterns (e.g., Bill, Income, Subscription).
    /// - Merchants: Enriches transactions with merchant name.
    /// - Classifications: Provides more insight into the type of money movement
    ///   that is occurring on the transaction, whether it be retail or
    ///   investments.
    /// - Geolocation: Provides geographic metadata.
    ///
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `to_created_at`: Filter transaction to the date in which the
    ///   transaction was created. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `to_date`: Filter transactions to this date (at midnight). This only
    ///   supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5
    ///   days forward from the day the request is made to capture pending
    ///   transactions.
    /// - `to_updated_at`: Filter transactions to the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `top_level_category_guid`: Filter transactions belonging to specified
    ///   `top_level_category_guid`. This must be top level category guid, use
    ///   `category_guid` for subcategory guid.
    ///
    ///For example,
    /// `?top_level_category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `top_level_category_guid`: Filter transactions belonging to any
    ///   specified `top_level_category_guid[]` in url. This must be top level
    ///   category guid(s), use `category_guid` for subcategory guid(s).
    ///
    ///For example,
    /// `?top_level_category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    pub async fn list_transactions_by_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        category_guid: Option<&'a str>,
        from_created_at: Option<&'a str>,
        from_date: Option<&'a str>,
        from_updated_at: Option<&'a str>,
        includes: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        to_created_at: Option<&'a str>,
        to_date: Option<&'a str>,
        to_updated_at: Option<&'a str>,
        top_level_category_guid: Option<&'a str>,
    ) -> Result<ResponseValue<types::TransactionsResponseBodyIncludes>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "category_guid",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "category_guid[]",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "from_created_at",
                &from_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("from_date", &from_date))
            .query(&progenitor_client::QueryParam::new(
                "from_updated_at",
                &from_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new("includes", &includes))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new(
                "to_created_at",
                &to_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("to_date", &to_date))
            .query(&progenitor_client::QueryParam::new(
                "to_updated_at",
                &to_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid",
                &top_level_category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid[]",
                &top_level_category_guid,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_transactions_by_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Verify member
    ///
    ///The verify endpoint begins a verification process for a member.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/verify`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `x_callback_payload`: The base64 encoded string defined in this header
    ///   will be returned in the [Member](/resources/webhooks/member/) and
    ///   [Member Data Updated](/resources/webhooks/member#member-data-updated)
    ///   webhooks. This allows you to trace user interactions and workflows
    ///   initiated externally and internally in the MX Platform. Max 1024
    ///   characters.
    pub async fn verify_member<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        x_callback_payload: Option<&'a str>,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/verify",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = x_callback_payload {
            header_map.append("X-CALLBACK-PAYLOAD", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "verify_member",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List spending plan iteration items
    ///
    ///Use this endpoint to list all the spending plan `iteration_items`
    /// associated with the `iteration`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// current/iteration_items`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_spending_plan_iteration_items<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanIterationItemsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/current/iteration_items",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_spending_plan_iteration_items",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create spending plan iteration item
    ///
    ///This endpoint creates a new `spending_plan_iteration_item`.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// current/iteration_items`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `body`: Iteration item to be created with required parameter
    ///   (planned_amount)
    pub async fn create_spending_plan_iteration_item<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        body: &'a types::SpendingPlanIterationItemCreateRequestBody,
    ) -> Result<ResponseValue<types::SpendingPlanIterationItemResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/current/iteration_items",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_spending_plan_iteration_item",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List spending plans
    ///
    ///Use this endpoint to list all the spending plans associated with the
    /// user.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/spending_plans`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_spending_plans<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlansResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_spending_plans",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create spending plan
    ///
    ///This endpoint creates a new `spending_plan` for the user.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/spending_plans`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn create_spending_plan<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::SpendingPlanResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_spending_plan",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read spending plan account
    ///
    ///Use this endpoint to read the attributes of a specific spending plan
    /// account according to its unique GUID.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/
    /// spending_plan_accounts/{spending_plan_account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `spending_plan_account_guid`: The unique ID for the specified account.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn read_spending_plan_account<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        spending_plan_account_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanAccountResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/spending_plan_accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
            encode_path(&spending_plan_account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_spending_plan_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete spending plan account
    ///
    ///Use this endpoint to delete a `spending_plan_account`.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/
    /// spending_plan_accounts/{spending_plan_account_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `spending_plan_account_guid`: The unique ID for the specified account.
    pub async fn delete_spending_plan_account<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        spending_plan_account_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/spending_plan_accounts/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
            encode_path(&spending_plan_account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_spending_plan_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a spending plan iteration item
    ///
    ///Use this endpoint to read the attributes of a specific spending plan
    /// `iteration_item` according to its unique GUID.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// current/iteration_items/{iteration_item_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `iteration_item_guid`: The unique ID for the `iteration_item`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn read_spending_plan_iteration_item<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        iteration_item_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanIterationItemResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/current/iteration_items/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
            encode_path(&iteration_item_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_spending_plan_iteration_item",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update a spending plan iteration item
    ///
    ///Use this endpoint to update an existing `spending_plan_iteration_item`.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// current/iteration_items/{iteration_item_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `iteration_item_guid`: The unique ID for the `iteration_item`.
    /// - `body`: Iteration item to be updated with required parameter
    ///   (planned_amount)
    pub async fn update_spending_plan_iteration_item<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        iteration_item_guid: &'a str,
        body: &'a types::SpendingPlanIterationItemCreateRequestBody,
    ) -> Result<ResponseValue<types::SpendingPlanIterationItemResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/current/iteration_items/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
            encode_path(&iteration_item_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_spending_plan_iteration_item",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete spending plan iteration item
    ///
    ///Use this endpoint to delete a spending plan `iteration_item`.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// current/iteration_items/{iteration_item_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `iteration_item_guid`: The unique ID for the `iteration_item`.
    pub async fn delete_spending_plan_iteration_item<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        iteration_item_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/current/iteration_items/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
            encode_path(&iteration_item_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_spending_plan_iteration_item",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a spending plan for a user
    ///
    ///Use this endpoint to read the attributes of a specific spending plan
    /// according to its unique GUID.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn read_spending_plan_user<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_spending_plan_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete spending plan
    ///
    ///Use this endpoint to delete a user's `spending_plan`.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    pub async fn delete_spending_plan<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_spending_plan",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List spending plan accounts
    ///
    ///Use this endpoint to list all the spending plan accounts associated with
    /// the spending plan.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/
    /// spending_plan_accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_spending_plan_accounts<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanAccountsResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/spending_plan_accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_spending_plan_accounts",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List spending plan iterations
    ///
    ///Use this endpoint to list all the spending plan `iterations` associated
    /// with the `spending_plan`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_spending_plan_iterations<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanIterationsResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_spending_plan_iterations",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read current spending plan iteration
    ///
    ///Use this endpoint to read the attributes of the current spending plan
    /// `iteration`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// current`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn read_current_spending_plan_iteration<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanIterationResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/current",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_current_spending_plan_iteration",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a spending plan iteration
    ///
    ///Use this endpoint to read the attributes of a specific spending plan
    /// `iteration` according to its `iteration_number`.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/spending_plans/{spending_plan_guid}/iterations/
    /// {iteration_number}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `spending_plan_guid`: The unique ID for the `spending_plan`.
    /// - `iteration_number`: The current iteration number for the spending plan
    ///   `iteration`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn read_spending_plan_iteration<'a>(
        &'a self,
        user_guid: &'a str,
        spending_plan_guid: &'a str,
        iteration_number: i64,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::SpendingPlanIterationResponse>, Error<()>> {
        let url = format!(
            "{}/users/{}/spending_plans/{}/iterations/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&spending_plan_guid.to_string()),
            encode_path(&iteration_number.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_spending_plan_iteration",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List taggings
    ///
    ///Use this endpoint to retrieve a list of all the taggings associated with
    /// a specific user.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/taggings`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_taggings<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::TaggingsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/taggings",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_taggings",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create tagging
    ///
    ///Use this endpoint to create a new association between a tag and a
    /// particular transaction, according to their unique GUIDs.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/taggings`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: Tagging object to be created with required parameters
    ///   (tag_guid and transaction_guid)
    pub async fn create_tagging<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::TaggingCreateRequestBody,
    ) -> Result<ResponseValue<types::TaggingResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/taggings",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_tagging",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read tagging
    ///
    ///Use this endpoint to read the attributes of a `tagging` according to its
    /// unique GUID.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/taggings/{tagging_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tagging_guid`: The unique id for a `tagging`.
    pub async fn read_tagging<'a>(
        &'a self,
        user_guid: &'a str,
        tagging_guid: &'a str,
    ) -> Result<ResponseValue<types::TaggingResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/taggings/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tagging_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_tagging",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update tagging
    ///
    ///Use this endpoint to update a tagging.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/taggings/{tagging_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tagging_guid`: The unique id for a `tagging`.
    /// - `body`: Tagging object to be updated with required parameter
    ///   (tag_guid)
    pub async fn update_tagging<'a>(
        &'a self,
        user_guid: &'a str,
        tagging_guid: &'a str,
        body: &'a types::TaggingUpdateRequestBody,
    ) -> Result<ResponseValue<types::TaggingResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/taggings/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tagging_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_tagging",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete tagging
    ///
    ///Use this endpoint to delete a tagging according to its unique GUID. If
    /// successful, the API will respond with an empty body and a status of 204
    /// NO Content.
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}/taggings/{tagging_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tagging_guid`: The unique id for a `tagging`.
    pub async fn delete_tagging<'a>(
        &'a self,
        user_guid: &'a str,
        tagging_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/taggings/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tagging_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_tagging",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List tags
    ///
    ///Use this endpoint to list all tags associated with the specified `user`.
    /// Each user includes the `Business` tag by default.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/tags`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_tags<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::TagsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/tags",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_tags",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create tag
    ///
    ///Use this endpoint to create a new custom tag.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/tags`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: Tag object to be created with required parameters (tag_guid)
    pub async fn create_tag<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::TagCreateRequestBody,
    ) -> Result<ResponseValue<types::TagResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/tags",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_tag",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read tag
    ///
    ///Use this endpoint to read the attributes of a particular tag according
    /// to its unique GUID.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/tags/{tag_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tag_guid`: The unique id for a `tag`.
    pub async fn read_tag<'a>(
        &'a self,
        user_guid: &'a str,
        tag_guid: &'a str,
    ) -> Result<ResponseValue<types::TagResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/tags/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tag_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_tag",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update tag
    ///
    ///Use this endpoint to update the name of a specific tag according to its
    /// unique GUID.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/tags/{tag_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tag_guid`: The unique id for a `tag`.
    /// - `body`: Tag object to be updated with required parameter (tag_guid)
    pub async fn update_tag<'a>(
        &'a self,
        user_guid: &'a str,
        tag_guid: &'a str,
        body: &'a types::TagUpdateRequestBody,
    ) -> Result<ResponseValue<types::TagResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/tags/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tag_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_tag",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete tag
    ///
    ///Use this endpoint to permanently delete a specific tag based on its
    /// unique GUID. If successful, the API will respond with status of `204 No
    /// Content`.
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}/tags/{tag_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tag_guid`: The unique id for a `tag`.
    /// - `accept`: Specifies the media type expected in the response.
    pub async fn delete_tag<'a>(
        &'a self,
        user_guid: &'a str,
        tag_guid: &'a str,
        accept: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/tags/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tag_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        header_map.append("Accept", accept.to_string().try_into()?);
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_tag",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List transactions by tag
    ///
    ///Use this endpoint to get a list of all transactions associated with a
    /// particular tag according to the tag's unique GUID. This lists all
    /// transactions that have been assigned to a particular tag using the
    /// create tagging endpoint. <br /><br />Enhanced transaction data may be
    /// requested using the `includes` parameter. To use this optional
    /// parameter, the value should include the optional metadata requested such
    /// as `repeating_transactions`, `merchants`, `classifications`,
    /// `geolocations`. For more information, see the [Optional Enhancement
    /// Query Parameter
    /// guide](/api-reference/platform-api/reference/transactions-overview#
    /// enhanced-transactions#optional-enhancement-query-parameter).
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/tags/{tag_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `tag_guid`: The unique id for a `tag`.
    /// - `category_guid`: Filter transactions belonging to specified
    ///   `category_guid`.
    ///
    ///For example, `?category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `category_guid`: Filter transactions belonging to any specified
    ///   `category_guid[]` in url.
    ///
    ///For example,
    /// `?category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `from_created_at`: Filter transactions from the date the transaction
    ///   was created. This only supports ISO 8601 format without timestamp
    ///   (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `from_date`: Filter transactions from this date. This only supports
    ///   ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days
    ///   ago if not provided.
    /// - `from_updated_at`: Filter transactions from the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `includes`: Options for enhanced transactions. This query parameter is
    ///   optional. Possible additional metadata: `repeating_transactions`,
    ///   `merchants`, `classifications`, `geolocations`. The query value is
    ///   format sensitive. To retrieve all available enhancements, append:
    ///
    ///`?includes=repeating_transactions,merchants,classifications,
    /// geolocations`.
    ///
    ///The query options may be combined to specific enhancements. For example,
    /// to request Repeating Transactions and Geolocation data, use:
    ///
    ///`?includes=repeating_transactions,geolocations`.
    ///
    /// - Repeating Transactions: Identifies transactions with predictable
    ///   recurrence patterns (e.g., Bill, Income, Subscription).
    /// - Merchants: Enriches transactions with merchant name.
    /// - Classifications: Provides more insight into the type of money movement
    ///   that is occurring on the transaction, whether it be retail or
    ///   investments.
    /// - Geolocation: Provides geographic metadata.
    ///
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `to_created_at`: Filter transaction to the date in which the
    ///   transaction was created. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `to_date`: Filter transactions to this date (at midnight). This only
    ///   supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5
    ///   days forward from the day the request is made to capture pending
    ///   transactions.
    /// - `to_updated_at`: Filter transactions to the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `top_level_category_guid`: Filter transactions belonging to specified
    ///   `top_level_category_guid`. This must be top level category guid, use
    ///   `category_guid` for subcategory guid.
    ///
    ///For example,
    /// `?top_level_category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `top_level_category_guid`: Filter transactions belonging to any
    ///   specified `top_level_category_guid[]` in url. This must be top level
    ///   category guid(s), use `category_guid` for subcategory guid(s).
    ///
    ///For example,
    /// `?top_level_category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `use_case`: The use case associated with the member. Valid values are
    ///   `PFM` and `MONEY_MOVEMENT`. For example, you can append either
    ///   `?use_case=PFM` or `?use_case=MONEY_MOVEMENT`.
    pub async fn list_transactions_by_tag<'a>(
        &'a self,
        user_guid: &'a str,
        tag_guid: &'a str,
        category_guid: Option<&'a str>,
        from_created_at: Option<&'a str>,
        from_date: Option<&'a str>,
        from_updated_at: Option<&'a str>,
        includes: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        to_created_at: Option<&'a str>,
        to_date: Option<&'a str>,
        to_updated_at: Option<&'a str>,
        top_level_category_guid: Option<&'a str>,
        use_case: Option<&'a str>,
    ) -> Result<ResponseValue<types::TransactionsResponseBodyIncludes>, Error<()>> {
        let url = format!(
            "{}/users/{}/tags/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&tag_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "category_guid",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "category_guid[]",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "from_created_at",
                &from_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("from_date", &from_date))
            .query(&progenitor_client::QueryParam::new(
                "from_updated_at",
                &from_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new("includes", &includes))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new(
                "to_created_at",
                &to_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("to_date", &to_date))
            .query(&progenitor_client::QueryParam::new(
                "to_updated_at",
                &to_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid",
                &top_level_category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid[]",
                &top_level_category_guid,
            ))
            .query(&progenitor_client::QueryParam::new("use_case", &use_case))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_transactions_by_tag",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List transaction rules
    ///
    ///Use this endpoint to read the attributes of all existing transaction
    /// rules belonging to the user.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/transaction_rules`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    pub async fn list_transaction_rules<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::TransactionRulesResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transaction_rules",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_transaction_rules",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create transaction rule
    ///
    ///Use this endpoint to create a new transaction rule. The newly-created
    /// `transaction_rule` object will be returned if successful.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/transaction_rules`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`: TransactionRule object to be created with optional parameters
    ///   (description) and required parameters (category_guid and
    ///   match_description)
    pub async fn create_transaction_rule<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::TransactionRuleCreateRequestBody,
    ) -> Result<ResponseValue<types::TransactionRuleResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transaction_rules",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_transaction_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read transaction rule
    ///
    ///Use this endpoint to read the attributes of an existing transaction rule
    /// based on the rules unique GUID.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/transaction_rules/{transaction_rule_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_rule_guid`: The unique id for a `transaction_rule`.
    pub async fn read_transaction_rule<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_rule_guid: &'a str,
    ) -> Result<ResponseValue<types::TransactionRuleResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transaction_rules/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_rule_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_transaction_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update transaction rule
    ///
    ///Use this endpoint to update the attributes of a specific transaction
    /// rule based on its unique GUID. The API will respond with the updated
    /// transaction_rule object. Any attributes not provided will be left
    /// unchanged.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/transaction_rules/{transaction_rule_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_rule_guid`: The unique id for a `transaction_rule`.
    /// - `body`: TransactionRule object to be updated
    pub async fn update_transaction_rule<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_rule_guid: &'a str,
        body: &'a types::TransactionRuleUpdateRequestBody,
    ) -> Result<ResponseValue<types::TransactionRuleResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transaction_rules/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_rule_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_transaction_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete transaction rule
    ///
    ///Use this endpoint to permanently delete a transaction rule based on its
    /// unique GUID.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/transaction_rules/{transaction_rule_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_rule_guid`: The unique id for a `transaction_rule`.
    pub async fn delete_transaction_rule<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_rule_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/transaction_rules/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_rule_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_transaction_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List transactions
    ///
    ///Requests to this endpoint return a list of transactions associated with
    /// the specified `user`, across all members and accounts associated with
    /// that `user`. <br /><br />Enhanced transaction data may be requested
    /// using the `includes` parameter. To use this optional parameter, the
    /// value should include the optional metadata requested such as
    /// `repeating_transactions`, `merchants`, `classifications`,
    /// `geolocations`. For more information, see the [Optional Enhancement
    /// Query Parameter
    /// guide](/api-reference/platform-api/reference/transactions-overview#
    /// enhanced-transactions#optional-enhancement-query-parameter).
    ///
    ///Sends a `GET` request to `/users/{user_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `category_guid`: Filter transactions belonging to specified
    ///   `category_guid`.
    ///
    ///For example, `?category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `category_guid`: Filter transactions belonging to any specified
    ///   `category_guid[]` in url.
    ///
    ///For example,
    /// `?category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `from_created_at`: Filter transactions from the date the transaction
    ///   was created. This only supports ISO 8601 format without timestamp
    ///   (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `from_date`: Filter transactions from this date. This only supports
    ///   ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days
    ///   ago if not provided.
    /// - `from_updated_at`: Filter transactions from the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `includes`: Options for enhanced transactions. This query parameter is
    ///   optional. Possible additional metadata: `repeating_transactions`,
    ///   `merchants`, `classifications`, `geolocations`. The query value is
    ///   format sensitive. To retrieve all available enhancements, append:
    ///
    ///`?includes=repeating_transactions,merchants,classifications,
    /// geolocations`.
    ///
    ///The query options may be combined to specific enhancements. For example,
    /// to request Repeating Transactions and Geolocation data, use:
    ///
    ///`?includes=repeating_transactions,geolocations`.
    ///
    /// - Repeating Transactions: Identifies transactions with predictable
    ///   recurrence patterns (e.g., Bill, Income, Subscription).
    /// - Merchants: Enriches transactions with merchant name.
    /// - Classifications: Provides more insight into the type of money movement
    ///   that is occurring on the transaction, whether it be retail or
    ///   investments.
    /// - Geolocation: Provides geographic metadata.
    ///
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `to_created_at`: Filter transaction to the date in which the
    ///   transaction was created. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `to_date`: Filter transactions to this date (at midnight). This only
    ///   supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5
    ///   days forward from the day the request is made to capture pending
    ///   transactions.
    /// - `to_updated_at`: Filter transactions to the date in which the
    ///   transaction was updated. This only supports ISO 8601 format without
    ///   timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
    /// - `top_level_category_guid`: Filter transactions belonging to specified
    ///   `top_level_category_guid`. This must be top level category guid, use
    ///   `category_guid` for subcategory guid.
    ///
    ///For example,
    /// `?top_level_category_guid=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `top_level_category_guid`: Filter transactions belonging to any
    ///   specified `top_level_category_guid[]` in url. This must be top level
    ///   category guid(s), use `category_guid` for subcategory guid(s).
    ///
    ///For example,
    /// `?top_level_category_guid[]=CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874`.
    /// - `use_case`: The use case associated with the member. Valid values are
    ///   `PFM` and `MONEY_MOVEMENT`. For example, you can append either
    ///   `?use_case=PFM` or `?use_case=MONEY_MOVEMENT`.
    pub async fn list_transactions<'a>(
        &'a self,
        user_guid: &'a str,
        category_guid: Option<&'a str>,
        from_created_at: Option<&'a str>,
        from_date: Option<&'a str>,
        from_updated_at: Option<&'a str>,
        includes: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        to_created_at: Option<&'a str>,
        to_date: Option<&'a str>,
        to_updated_at: Option<&'a str>,
        top_level_category_guid: Option<&'a str>,
        use_case: Option<&'a str>,
    ) -> Result<ResponseValue<types::TransactionsResponseBodyIncludes>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "category_guid",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "category_guid[]",
                &category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "from_created_at",
                &from_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("from_date", &from_date))
            .query(&progenitor_client::QueryParam::new(
                "from_updated_at",
                &from_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new("includes", &includes))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new(
                "to_created_at",
                &to_created_at,
            ))
            .query(&progenitor_client::QueryParam::new("to_date", &to_date))
            .query(&progenitor_client::QueryParam::new(
                "to_updated_at",
                &to_updated_at,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid",
                &top_level_category_guid,
            ))
            .query(&progenitor_client::QueryParam::new(
                "top_level_category_guid[]",
                &top_level_category_guid,
            ))
            .query(&progenitor_client::QueryParam::new("use_case", &use_case))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read transaction
    ///
    ///Requests to this endpoint will return the attributes of the specified
    /// `transaction`. To read a manual transaction, use the manual transaction
    /// guid in the path as the `transactionGuid`. <br /><br />Enhanced
    /// transaction data may be requested using the `includes` parameter. To use
    /// this optional parameter, the value should include the optional metadata
    /// requested such as `repeating_transactions`, `merchants`,
    /// `classifications`, `geolocations`. For more information, see the
    /// [Optional Enhancement Query Parameter
    /// guide](/api-reference/platform-api/reference/transactions-overview#
    /// enhanced-transactions#optional-enhancement-query-parameter).
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    /// - `includes`: Options for enhanced transactions. This query parameter is
    ///   optional. Possible additional metadata: `repeating_transactions`,
    ///   `merchants`, `classifications`, `geolocations`. The query value is
    ///   format sensitive. To retrieve all available enhancements, append:
    ///
    ///`?includes=repeating_transactions,merchants,classifications,
    /// geolocations`.
    ///
    ///The query options may be combined to specific enhancements. For example,
    /// to request Repeating Transactions and Geolocation data, use:
    ///
    ///`?includes=repeating_transactions,geolocations`.
    ///
    /// - Repeating Transactions: Identifies transactions with predictable
    ///   recurrence patterns (e.g., Bill, Income, Subscription).
    /// - Merchants: Enriches transactions with merchant name.
    /// - Classifications: Provides more insight into the type of money movement
    ///   that is occurring on the transaction, whether it be retail or
    ///   investments.
    /// - Geolocation: Provides geographic metadata.
    pub async fn read_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_guid: &'a str,
        includes: Option<&'a str>,
    ) -> Result<ResponseValue<types::TransactionsResponseBodyIncludes>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("includes", &includes))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update transaction
    ///
    ///Use this endpoint to update a specific transaction according to its
    /// unique GUID.
    ///
    ///Sends a `PUT` request to
    /// `/users/{user_guid}/transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    /// - `body`: Transaction object with the fields to be updated.
    pub async fn update_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_guid: &'a str,
        body: &'a types::TransactionUpdateRequestBody,
    ) -> Result<ResponseValue<types::TransactionResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete manual transactions
    ///
    ///Delete a manual transaction. In the path, use the manual transaction
    /// guid as the `transaction_guid`, such as
    /// `MAN-810828b0-5210-4878-9bd3-f4ce514f90c4`.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/transactions/{transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    pub async fn delete_manual_transactions<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_manual_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Request widget URL
    ///
    ///Get an embeddable URL for integrating a widget into your website or app.
    /// The URL expires after ten minutes or upon first use, whichever occurs
    /// first. You'll need to obtain a new URL each time the page loads or
    /// reloads.
    ///
    ///Include the `widget_type` in the request body to specify which widget
    /// you want to embedthe Connect Widget, a Personal Financial Management
    /// widget, or an Insights widget. Some request parameters are specific to
    /// certain widget types.
    ///
    ///To embed the Connect Widget, set `widget_type` to `connect_widget`.
    ///
    ///For a full list of available widget types, see [Widget
    /// Types](/api-reference/platform-api/reference/widgets#widget-types).
    ///
    ///
    ///Sends a `POST` request to `/users/{user_guid}/widget_urls`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `accept_language`: The desired language of the widget.
    /// - `x_callback_payload`: The base64 encoded string defined in this header
    ///   will be returned in the [Member](/resources/webhooks/member/) and
    ///   [Member Data Updated](/resources/webhooks/member#member-data-updated)
    ///   webhooks. This allows you to trace user interactions and workflows
    ///   initiated externally and internally in the MX Platform. Max 1024
    ///   characters.
    /// - `body`: The widget url configuration options.
    pub async fn request_widget_url<'a>(
        &'a self,
        user_guid: &'a str,
        accept_language: Option<&'a str>,
        x_callback_payload: Option<&'a str>,
        body: &'a types::WidgetRequestBody,
    ) -> Result<ResponseValue<types::WidgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/widget_urls",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = accept_language {
            header_map.append("Accept-Language", value.to_string().try_into()?);
        }

        if let Some(value) = x_callback_payload {
            header_map.append("X-CALLBACK-PAYLOAD", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "request_widget_url",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Auto-generate budgets
    ///
    ///This endpoint will automatically create budgets for several categories
    /// based on existing transactions; these budgets are returned as an array.
    /// Specifically, budgets will only be generated if the `user` has at least
    /// one `transaction` in a given category during each of the two previous
    /// calendar months. For example, if the request is made on March 6, and
    /// there is at least one "Bills & Utilities" `transaction` in both January
    /// and February, a budget will be generated for "Bills & Utilities." If
    /// there are two "Bills & Utilities" transactions in February but none in
    /// January, no budget will be generated for that category. If budgets
    /// already exist for particular categories, new budgets will be generated
    /// and returned based on the available transactions. If one or more budgets
    /// remain unchanged, they will nevertheless be returned in the response. If
    /// no transaction data for the `user` meet the above criteria, a `422
    /// Unprocessable Entity` error will be returned with status code 4221 along
    /// with the message, `There aren't enough transactions to automatically
    /// create any budgets`.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/budgets/generate`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn auto_generate_budgets<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::BudgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/budgets/generate",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "auto_generate_budgets",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all budgets
    ///
    ///List all budgets
    ///
    ///Sends a `GET` request to `/users/{user_guid}/budgets`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn list_all_budgets<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::BudgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/budgets",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_all_budgets",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a budget
    ///
    ///Create a budget. This endpoint accepts the optional `MX-Skip-Webhook`
    /// header and `skip_webhook` parameter. You cannot create a duplicate
    /// budget. For example, if you attempt to create a budget for "Gas", but
    /// that budget already exist, the request will fail. You can retrieve a
    /// list of all existing categories by using the List Categories endpoint.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/budgets`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`
    pub async fn create_budget<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::BudgetCreateRequestBody,
    ) -> Result<ResponseValue<types::BudgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/budgets",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_budget",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a specific budget
    ///
    ///Read a specific budget.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/budgets/{budget_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `budget_guid`: The unique identifier for the budget. Defined by MX.
    pub async fn read_specific_budget<'a>(
        &'a self,
        user_guid: &'a str,
        budget_guid: &'a str,
    ) -> Result<ResponseValue<types::BudgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/budgets/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&budget_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_specific_budget",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update a specific budget
    ///
    ///Update a specific budget.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/budgets/{budget_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `budget_guid`: The unique identifier for the budget. Defined by MX.
    /// - `body`
    pub async fn update_specific_budget<'a>(
        &'a self,
        user_guid: &'a str,
        budget_guid: &'a str,
        body: &'a types::BudgetUpdateRequestBody,
    ) -> Result<ResponseValue<types::BudgetResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/budgets/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&budget_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_specific_budget",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a budget
    ///
    ///Delete a budget.
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}/budgets/{budget_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `budget_guid`: The unique identifier for the budget. Defined by MX.
    pub async fn delete_budget<'a>(
        &'a self,
        user_guid: &'a str,
        budget_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/budgets/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&budget_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_budget",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List goals
    ///
    ///List all goals a user can set.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/goals`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `accept`: Specifies the media type expected in the response.
    pub async fn list_goals<'a>(
        &'a self,
        user_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
        accept: &'a str,
    ) -> Result<ResponseValue<types::GoalsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/goals",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        header_map.append("Accept", accept.to_string().try_into()?);
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_goals",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a goal
    ///
    ///Create a goal. This endpoint accepts the optional `MX-Skip-Webhook`
    /// header and `skip_webhook` parameter.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/goals`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`
    pub async fn create_goal<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::GoalRequestBody,
    ) -> Result<ResponseValue<types::GoalResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/goals",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_goal",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a goal
    ///
    ///Read a specific goal.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/goals/{goal_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `goal_guid`: The unique identifier for a goal. Defined by MX.
    pub async fn read_goal<'a>(
        &'a self,
        user_guid: &'a str,
        goal_guid: &'a str,
    ) -> Result<ResponseValue<types::GoalResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/goals/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&goal_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_goal",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update a goal
    ///
    ///This endpoint updates a specific goal.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/goals/{goal_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `goal_guid`: The unique identifier for a goal. Defined by MX.
    /// - `body`
    pub async fn update_goal<'a>(
        &'a self,
        user_guid: &'a str,
        goal_guid: &'a str,
        body: &'a types::UpdateGoalRequestBody,
    ) -> Result<ResponseValue<types::GoalResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/goals/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&goal_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_goal",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a goal
    ///
    ///Delete a goal.
    ///
    ///Sends a `DELETE` request to `/users/{user_guid}/goals/{goal_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `goal_guid`: The unique identifier for a goal. Defined by MX.
    /// - `accept`: Specifies the media type expected in the response.
    pub async fn delete_goal<'a>(
        &'a self,
        user_guid: &'a str,
        goal_guid: &'a str,
        accept: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/goals/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&goal_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        header_map.append("Accept", accept.to_string().try_into()?);
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_goal",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Reposition goals
    ///
    ///This endpoint repositions goal priority levels. If one goal is set to a
    /// lower priority, then any other goals need to be adjusted accordingly.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/goals/reposition`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`
    pub async fn reposition_goals<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::RepositionRequestBody,
    ) -> Result<ResponseValue<types::RepositionResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/goals/reposition",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "reposition_goals",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List notifications
    ///
    ///All notifications for the user can be listed, including notifications
    /// created by MX for other channels besides `PUSH`.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/notifications`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `from_date`: Filter transactions from this date. This only supports
    ///   ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days
    ///   ago if not provided.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `1000`. If the value exceeds `1000`, the default value of `25` will
    ///   be used instead.
    /// - `to_date`: Filter transactions to this date (at midnight). This only
    ///   supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5
    ///   days forward from the day the request is made to capture pending
    ///   transactions.
    pub async fn list_notifications<'a>(
        &'a self,
        user_guid: &'a str,
        from_date: Option<&'a str>,
        page: Option<i64>,
        records_per_page: Option<i64>,
        to_date: Option<&'a str>,
    ) -> Result<ResponseValue<types::NotificationsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/notifications",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("from_date", &from_date))
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .query(&progenitor_client::QueryParam::new("to_date", &to_date))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_notifications",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a notification
    ///
    ///All notifications created through the API will be of notification type
    /// `API_NOTIFICATION`, channel `PUSH`, and will not be associated to an
    /// entity.  No other channels are supported.  This will only have an effect
    /// for clients using an MX mobile application.
    ///
    ///Sends a `POST` request to `/users/{user_guid}/notifications`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `content`: The information related to the notification.
    /// - `subject`: The subject related to the notification.
    pub async fn create_notification<'a>(
        &'a self,
        user_guid: &'a str,
        content: &'a str,
        subject: &'a str,
    ) -> Result<ResponseValue<types::NotificationResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/notifications",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("content", &content))
            .query(&progenitor_client::QueryParam::new("subject", &subject))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_notification",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read notifications
    ///
    ///Can pull up any notification associated with the user, including
    /// notifications created by MX for other channels besides `PUSH`.
    ///
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/notifications/{notification_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `notification_guid`: The unique identifier for notifications. Defined
    ///   by MX.
    pub async fn read_notifications<'a>(
        &'a self,
        user_guid: &'a str,
        notification_guid: &'a str,
    ) -> Result<ResponseValue<types::NotificationResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/notifications/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&notification_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_notifications",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List Repeating Transactions
    ///
    ///Retrieve a list of all recurring transactions for a user. <br /><br
    /// />For more see the [Repeating Transactions
    /// guide](repeating-transactions-overview.mdx).
    ///
    ///Sends a `GET` request to `/users/{user_guid}/repeating_transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn repeating_transactions<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::RepeatingTransactionsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/repeating_transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "repeating_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a Repeating Transaction
    ///
    ///Get a Specific Repeating Transaction. <br /><br />List For more see the
    /// [Repeating Transactions guide](repeating-transactions-overview.mdx)
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/repeating_transactions/{repeating_transaction_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `repeating_transaction_guid`: The unique id for a recurring
    ///   transaction.
    pub async fn specific_repeating_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        repeating_transaction_guid: &'a str,
    ) -> Result<ResponseValue<types::RepeatingTransactionsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/repeating_transactions/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&repeating_transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "specific_repeating_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List insights by transaction
    ///
    ///Use this endpoint to list all insights associated with a transaction
    /// GUID.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/transactions/{transaction_guid}/insights`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    /// - `page`: Results are paginated. Specify current page.
    /// - `records_per_page`: This specifies the number of records to be
    ///   returned on each page. Defaults to `25`. The valid range is from `10`
    ///   to `100`. If the value exceeds `100`, the default value of `25` will
    ///   be used instead.
    pub async fn list_insights_by_transaction<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_guid: &'a str,
        page: Option<i64>,
        records_per_page: Option<i64>,
    ) -> Result<ResponseValue<types::InsightsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions/{}/insights",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("page", &page))
            .query(&progenitor_client::QueryParam::new(
                "records_per_page",
                &records_per_page,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_insights_by_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create split transactions
    ///
    ///This endpoint creates two or more child transactions that are branched
    /// from a previous transaction. This endpoint allows you to link multiple
    /// categories, descriptions, and amounts to a parent transaction.  When a
    /// split transaction is created, the parent transaction's `has_been_split`
    /// field will automatically be updated to true and the child transactions'
    /// `parent_guid` will have the transaction guid of the parent. The total
    /// amount of the child transactions must equal the amount of the parent
    /// transaction. Once a transaction has been split it can't be split again.
    /// In order to re-split a transaction, it must first be un-split. This can
    /// be done by calling the Delete Split Transactions endpoint. Calling this
    /// endpoint will delete the existing child transactions and update the
    /// parent transaction's `has_been_split` field to false. You can then
    /// re-split the parent transaction by calling Create Split Transaction
    /// again.
    ///
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/transactions/{transaction_guid}/split`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    /// - `body`
    pub async fn create_split_transactions<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_guid: &'a str,
        body: &'a types::SplitTransactionRequestBody,
    ) -> Result<ResponseValue<types::SplitTransactionsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions/{}/split",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_split_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete split transactions
    ///
    ///This endpoint deletes all split transactions linked to a parent
    /// transaction, but it leaves the parent transaction active. This request
    /// will also update the parent transaction's has_been_split field to false.
    /// This endpoint accepts the optional MX-Skip-Webhook header.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/transactions/{transaction_guid}/split`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `transaction_guid`: The unique id for a `transaction`.
    pub async fn delete_split_transactions<'a>(
        &'a self,
        user_guid: &'a str,
        transaction_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/transactions/{}/split",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&transaction_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_split_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read monthly cash flow profile
    ///
    ///Read monthly cash flow profile.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/monthly_cash_flow_profile`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn read_monthly_cash_flow_profile<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::MonthlyCashFlowResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/monthly_cash_flow_profile",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_monthly_cash_flow_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update monthly cash flow profile
    ///
    ///Use this endpoint to update the attributes of a
    /// `monthly_cash_flow_profile`.
    ///
    ///Sends a `PUT` request to `/users/{user_guid}/monthly_cash_flow_profile`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`
    pub async fn update_monthly_cash_flow_profile<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::MonthlyCashFlowProfileRequestBody,
    ) -> Result<ResponseValue<types::MonthlyCashFlowResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/monthly_cash_flow_profile",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_monthly_cash_flow_profile",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///View a List of Tokens
    ///
    ///View a list of tokens that exist for a user, member, or account.
    ///
    ///Sends a `GET` request to `/tokens`
    pub async fn list_tokens<'a>(
        &'a self,
        body: &'a types::TokenRequestBody,
    ) -> Result<ResponseValue<types::TokenResponseBody>, Error<()>> {
        let url = format!("{}/tokens", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_tokens",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Request an account number (Processors Only)
    ///
    ///Get account information such as routing number and account number,
    /// scoped to your access token.
    ///
    ///Sends a `GET` request to `/account/account_numbers`
    pub async fn request_account_number<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::ProcessorAccountNumberBody>, Error<()>> {
        let url = format!("{}/account/account_numbers", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "request_account_number",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Check Real Time Account Balance (Processors Only)
    ///
    ///Check the real-time account balance using your access token.
    ///
    ///Sends a `POST` request to `/account/check_balance`
    pub async fn check_real_time_account_balance<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!("{}/account/check_balance", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "check_real_time_account_balance",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read the account balance (Processors Only)
    ///
    ///Read the account balance (Processors Only)
    ///
    ///Sends a `GET` request to `/payment_account`
    pub async fn read_account_balance<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::PaymentAccountBody>, Error<()>> {
        let url = format!("{}/payment_account", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_account_balance",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get account owner information (Processors Only)
    ///
    ///Get account owner information (Processors Only)
    ///
    ///Sends a `GET` request to `/account/transactions`
    pub async fn get_account_owner_info<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::ProcessorOwnerBody>, Error<()>> {
        let url = format!("{}/account/transactions", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_account_owner_info",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all microdeposits for a user
    ///
    ///Use this endpoint to read the attributes of a specific microdeposit
    /// according to its unique GUID.
    ///
    ///Sends a `GET` request to `/users/{user_guid}/micro_deposits`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn list_user_microdeposits<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::MicrodepositsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/micro_deposits",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_user_microdeposits",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create or pre-initiate a microdeposit
    ///
    ///Use this endpoint to create or pre-initiate a microdeposit. The response
    /// will include the new microdeposit record with a status of `INITIATED` or
    /// `PREINITIATED` respectively.
    ///
    ///To pre-initiate a microdeposit, you only need to set `email` (string),
    /// `first_name` (string), and `last_name` (string) in the request body.
    ///
    ///Pre-initiating a microdeposit allows you to pass the end user's first
    /// name, last name, and email if this data has already been collected. If
    /// the end user selects an institution which requires the microdeposit
    /// flow, the pre-initiated `micro_deposit` will be used and the Connect
    /// Widget step that normally requests this info from the end user will be
    /// skipped. However, if the end user selects an institution which supports
    /// IAV, the pre-initiated `micro_deposit` will be deleted and IAV will be
    /// used instead. When requesting a Connect Widget URL after pre-initiating,
    /// make sure to set the `current_microdeposit_guid` to the resulting
    /// microdeposit's `guid` and set the `mode` to `verification`. If you use
    /// this enhanced flow, a `micro_deposit` should be pre-initiated for all
    /// connect sessions in verification mode. After pre-initiating a
    /// microdeposit, pass the GUID to the config as `current_microdeposit_guid`
    /// and set the `mode` to `verification` when requesting a Connect URL.
    /// Pre-initiating a microdeposit is optional. If you choose to implement
    /// this flow, it should be used for all Connect Widget sessions in
    /// verification mode.
    ///
    ///
    ///Sends a `POST` request to `/users/{user_guid}/micro_deposits`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `body`
    pub async fn create_microdeposit<'a>(
        &'a self,
        user_guid: &'a str,
        body: &'a types::MicrodepositRequestBody,
    ) -> Result<ResponseValue<types::MicrodepositResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/micro_deposits",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_microdeposit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a microdeposit for a user
    ///
    ///Use this endpoint to read the attributes of a specific microdeposit
    /// according to its unique GUID. <br /><br /> Webhooks for microdeposit
    /// status changes are triggered when a status changes. The actual status of
    /// the microdeposit guid updates every minute. You may force a status
    /// update by calling the read microdeposit endpoint.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/micro_deposits/{micro_deposit_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `micro_deposit_guid`: The unique identifier for the microdeposit.
    ///   Defined by MX.
    pub async fn read_user_microdeposit<'a>(
        &'a self,
        user_guid: &'a str,
        micro_deposit_guid: &'a str,
    ) -> Result<ResponseValue<types::MicrodepositResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/micro_deposits/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&micro_deposit_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_user_microdeposit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete a microdeposit
    ///
    ///Use this endpoint to delete the specified microdeposit.
    ///
    ///Sends a `DELETE` request to
    /// `/users/{user_guid}/micro_deposits/{micro_deposit_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `micro_deposit_guid`: The unique identifier for the microdeposit.
    ///   Defined by MX.
    pub async fn delete_microdeposit<'a>(
        &'a self,
        user_guid: &'a str,
        micro_deposit_guid: &'a str,
    ) -> Result<ResponseValue<()>, Error<()>> {
        let url = format!(
            "{}/users/{}/micro_deposits/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&micro_deposit_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_microdeposit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Verify a Microdeposit
    ///
    ///Use this endpoint to verify the amounts deposited into the account
    /// during a microdeposit verification. The verification has not
    /// successfully completed until the `status` is `VERIFIED`. Poll the
    /// `/users/{user_guid}/micro_deposits/{micro_deposit_guid}` (read
    /// microdeposit) endpoint until you see this status or an error state.
    ///
    ///Sends a `PUT` request to `/micro_deposits/{micro_deposit_guid}/verify`
    ///
    ///Arguments:
    /// - `micro_deposit_guid`: The unique identifier for the microdeposit.
    ///   Defined by MX.
    /// - `body`
    pub async fn verify_microdeposit<'a>(
        &'a self,
        micro_deposit_guid: &'a str,
        body: &'a types::MicrodepositVerifyRequestBody,
    ) -> Result<ResponseValue<types::MicrodepositResponseBody>, Error<()>> {
        let url = format!(
            "{}/micro_deposits/{}/verify",
            self.baseurl,
            encode_path(&micro_deposit_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "verify_microdeposit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List all verifications for a user
    ///
    ///This endpoint returns a list of the account verifications associated
    /// with the user, as well as the status of those verifications.
    ///
    ///
    ///Sends a `GET` request to `/users/{user_guid}/account_verifications`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    pub async fn list_user_verifications<'a>(
        &'a self,
        user_guid: &'a str,
    ) -> Result<ResponseValue<types::MicrodepositResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/account_verifications",
            self.baseurl,
            encode_path(&user_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_user_verifications",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Fetch Rewards
    ///
    ///Calling this endpoint initiates an aggregation-type event which will
    /// gather the member's rewards information, as well as account and
    /// transaction information. Rewards data is also gathered with daily
    /// background aggregations. Member and Rewards guids are defined by MX.
    ///
    ///Sends a `POST` request to
    /// `/users/{user_guid}/members/{member_guid}/fetch_rewards`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn fetch_rewards<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::MemberResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/fetch_rewards",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "fetch_rewards",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///List Rewards
    ///
    ///Use this endpoint to list all the `rewards` associated with a specified
    /// `member`. Member guids are defined by MX.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/rewards`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn list_rewards<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<types::RewardsResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/rewards",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "list_rewards",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read Reward
    ///
    ///Use this endpoint to read a specific `reward` based on its unique GUID.
    /// Member and Rewards guids are defined by MX.
    ///
    ///Sends a `GET` request to
    /// `/users/{user_guid}/members/{member_guid}/rewards/{reward_guid}`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    /// - `reward_guid`: The unique identifier for the rewards. Defined by MX.
    pub async fn read_rewards<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
        reward_guid: &'a str,
    ) -> Result<ResponseValue<types::RewardResponseBody>, Error<()>> {
        let url = format!(
            "{}/users/{}/members/{}/rewards/{}",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
            encode_path(&reward_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "read_rewards",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Read a Credit Card Product
    ///
    ///This endpoint returns the specified `credit_card_product` according to
    /// the unique GUID.
    ///
    ///Sends a `GET` request to
    /// `/credit_card_products/{credit_card_product_guid}`
    ///
    ///Arguments:
    /// - `credit_card_product_guid`: The required `credit_card_product_guid`
    ///   can be found on the `account` object.
    pub async fn credit_card<'a>(
        &'a self,
        credit_card_product_guid: &'a str,
    ) -> Result<ResponseValue<types::CreditCardProductResponse>, Error<()>> {
        let url = format!(
            "{}/credit_card_products/{}",
            self.baseurl,
            encode_path(&credit_card_product_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "credit_card",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Identity Data
    ///
    ///Get an MX-issued verifiable credential of a user's identity data.
    ///
    ///Sends a `GET` request to
    /// `/vc/users/{user_guid}/members/{member_guid}/customers`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn get_identity_data<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/vc/users/{}/members/{}/customers",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "get_identity_data",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Accounts Data
    ///
    ///Get an MX-issued verifiable credential of a user's accounts data.
    ///
    ///Sends a `GET` request to
    /// `/vc/users/{user_guid}/members/{member_guid}/accounts`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `member_guid`: The unique id for a `member`.
    pub async fn get_accounts_data<'a>(
        &'a self,
        user_guid: &'a str,
        member_guid: &'a str,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/vc/users/{}/members/{}/accounts",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&member_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.get(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "get_accounts_data",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Transactions Data
    ///
    ///Get an MX-issued verifiable credential of a user's transaction data.
    ///
    ///Sends a `GET` request to
    /// `/vc/users/{user_guid}/accounts/{account_guid}/transactions`
    ///
    ///Arguments:
    /// - `user_guid`: The unique identifier for a `user`, beginning with the
    ///   prefix `USR-`.
    /// - `account_guid`: The unique id for an `account`.
    /// - `end_time`: Filter transactions to this date. Must be in the format
    ///   YYYY-MM-DD. The range is limited to 1 year.
    /// - `start_time`: Filter transactions from this date. Must be in the
    ///   format YYYY-MM-DD. The range is limited to 1 year.
    pub async fn get_transactions_data<'a>(
        &'a self,
        user_guid: &'a str,
        account_guid: &'a str,
        end_time: Option<&'a str>,
        start_time: Option<&'a str>,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!(
            "{}/vc/users/{}/accounts/{}/transactions",
            self.baseurl,
            encode_path(&user_guid.to_string()),
            encode_path(&account_guid.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .query(&progenitor_client::QueryParam::new("endTime", &end_time))
            .query(&progenitor_client::QueryParam::new(
                "startTime",
                &start_time,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_transactions_data",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}

/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
